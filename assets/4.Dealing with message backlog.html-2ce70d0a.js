import{_ as e,W as o,X as t,a2 as i}from"./framework-48328e23.js";const s={},a=i('<p>发生了消息积压，这时候就得想办法赶紧把积压的消息消费完，就得考虑提高消费能力，一般有两种办法：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503091131503.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>消费者扩容</strong>：如果当前 Topic 的 Message Queue 的数量大于消费者数量，就可以对消费者进行扩容，增加消费者，来提高消费能力，尽快把积压的消息消费完。或者<strong>增加消费者线程数量</strong>：提高并发消费能力（然后这里就会出现乱序消费的问题！）。<strong>优化消费者逻辑</strong>：检查消费者的代码，减少单个消息的处理时间。例如，减少 I/O 操作、使用批量处理等。</li><li><strong>消息迁移 Queue 扩容</strong>：如果当前 Topic 的 Message Queue 的数量小于或者等于消费者数量，这种情况，再扩容消费者就没什么用，就得考虑扩容 Message Queue。可以新建一个临时的 Topic，临时的 Topic 多设置一些 Message Queue，然后先用一些消费者把消费的数据丢到临时的 Topic，因为不用业务处理，只是转发一下消息，还是很快的。接下来用扩容的消费者去消费新的 Topic 里的数据，消费完了之后，恢复原状。</li></ul><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503091133374.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',4),c=[a];function g(n,l){return o(),t("div",null,c)}const p=e(s,[["render",g],["__file","4.Dealing with message backlog.html.vue"]]);export{p as default};
