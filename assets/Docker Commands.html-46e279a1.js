import{_ as l,W as c,X as p,$ as e,a0 as a,Z as s,a2 as n,C as d}from"./framework-6a3aa88c.js";const r={},t=n('<h1 id="_2-docker的基本操作" tabindex="-1"><a class="header-anchor" href="#_2-docker的基本操作" aria-hidden="true">#</a> 2.Docker的基本操作</h1><h2 id="_2-1-镜像操作" tabindex="-1"><a class="header-anchor" href="#_2-1-镜像操作" aria-hidden="true">#</a> 2.1.镜像操作</h2><h3 id="_2-1-1-镜像名称" tabindex="-1"><a class="header-anchor" href="#_2-1-1-镜像名称" aria-hidden="true">#</a> 2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p>如图：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/7ab7282084a7b300e0d3a69be6aece02.png" alt="image-20210731155141362" tabindex="0" loading="lazy"><figcaption>image-20210731155141362</figcaption></figure><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p><h3 id="_2-1-2-镜像命令" tabindex="-1"><a class="header-anchor" href="#_2-1-2-镜像命令" aria-hidden="true">#</a> 2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/17dc13b3ccbcd68103b46128aeb92a3b.png" alt="image-20210731155649535" tabindex="0" loading="lazy"><figcaption>image-20210731155649535</figcaption></figure><h3 id="_2-1-3-案例1-拉取、查看镜像" tabindex="-1"><a class="header-anchor" href="#_2-1-3-案例1-拉取、查看镜像" aria-hidden="true">#</a> 2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p>',13),o={href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"},g=n(`<figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/fb3217764d9edc6dc9bd7c790d91b369.png" alt="image-20210731155844368" tabindex="0" loading="lazy"><figcaption>image-20210731155844368</figcaption></figure><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/96c3175c44df69904142bafd2005f575.png" alt="image-20210731155856199" tabindex="0" loading="lazy"><figcaption>image-20210731155856199</figcaption></figure><p>3）通过命令：docker images 查看拉取到的镜像</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/2029ddb0e737f9bbf65a1c5502f71edb.png" alt="image-20210731155903037" tabindex="0" loading="lazy"><figcaption>image-20210731155903037</figcaption></figure><h3 id="_2-1-4-案例2-保存、导入镜像" tabindex="-1"><a class="header-anchor" href="#_2-1-4-案例2-保存、导入镜像" aria-hidden="true">#</a> 2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx --help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token parameter variable">--help</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/6bc12ec0cdea34d6ff72f11cae68cc74.png" alt="image-20210731161104732" tabindex="0" loading="lazy"><figcaption>image-20210731161104732</figcaption></figure><p>命令格式：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token parameter variable">-o</span> <span class="token punctuation">[</span>保存的目标文件名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2）使用docker save导出镜像到磁盘</p><p>运行命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token parameter variable">-o</span> nginx.tar nginx:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果如图：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/5e1888f5268e6ee81aef18cd33724795.png" alt="image-20210731161354344" tabindex="0" loading="lazy"><figcaption>image-20210731161354344</figcaption></figure><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi nginx:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后运行命令，加载本地文件：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> load <span class="token parameter variable">-i</span> nginx.tar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/cc83ebd764e46e90e81604548545fb06.png" alt="image-20210731161746245" tabindex="0" loading="lazy"><figcaption>image-20210731161746245</figcaption></figure><h3 id="_2-1-5-练习" tabindex="-1"><a class="header-anchor" href="#_2-1-5-练习" aria-hidden="true">#</a> 2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><p>1）去DockerHub搜索Redis镜像</p><p>2）查看Redis镜像的名称和版本</p><p>3）利用docker pull命令拉取镜像</p><p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p><p>5）利用docker rmi 删除本地的redis:latest</p><p>6）利用docker load 重新加载 redis.tar文件</p><h2 id="_2-2-容器操作" tabindex="-1"><a class="header-anchor" href="#_2-2-容器操作" aria-hidden="true">#</a> 2.2.容器操作</h2><h3 id="_2-2-1-容器相关命令" tabindex="-1"><a class="header-anchor" href="#_2-2-1-容器相关命令" aria-hidden="true">#</a> 2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/fcd89f6b617431b6f0be1c4f5145e5a3.png" alt="image-20210731161950495" tabindex="0" loading="lazy"><figcaption>image-20210731161950495</figcaption></figure><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程挂起，但不释放内存，内存暂存起来</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p></li></ul><h3 id="_2-2-2-案例-创建并运行一个容器" tabindex="-1"><a class="header-anchor" href="#_2-2-2-案例-创建并运行一个容器" aria-hidden="true">#</a> 2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> containerName <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>--name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/6d56acdf897ad6d4a765945aff3c353c.png" alt="image-20210731163255863" tabindex="0" loading="lazy"><figcaption>image-20210731163255863</figcaption></figure><h3 id="_2-2-3-案例-进入容器-修改文件" tabindex="-1"><a class="header-anchor" href="#_2-2-3-案例-进入容器-修改文件" aria-hidden="true">#</a> 2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mn <span class="token function">bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul><p>2）进入nginx的HTML所在目录 /usr/share/nginx/html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/b8d1a2000e4741866cc85a784e48409a.png" alt="image-20210731164159811" tabindex="0" loading="lazy"><figcaption>image-20210731164159811</figcaption></figure><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /usr/share/nginx/html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看目录下文件：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/b259f866372ddf082b112ffd1391ca04.png" alt="image-20210731164455818" tabindex="0" loading="lazy"><figcaption>image-20210731164455818</figcaption></figure><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;s#Welcome to nginx#春招顺利！！！#g&#39;</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#39;</span> index.html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,72),u={href:"http://8.140.248.10",target:"_blank",rel:"noopener noreferrer"},h=n(`<figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20241230100822780.png" alt="image-20241230100822780" tabindex="0" loading="lazy"><figcaption>image-20241230100822780</figcaption></figure><h3 id="_2-2-4-小结" tabindex="-1"><a class="header-anchor" href="#_2-2-4-小结" aria-hidden="true">#</a> 2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>--name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="_2-3-数据卷-容器数据管理" tabindex="-1"><a class="header-anchor" href="#_2-3-数据卷-容器数据管理" aria-hidden="true">#</a> 2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/353ad7725cb1ac9e7a11fb7c96bc24b7.png" alt="image-20210731172440275" tabindex="0" loading="lazy"><figcaption>image-20210731172440275</figcaption></figure><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h3 id="_2-3-1-什么是数据卷" tabindex="-1"><a class="header-anchor" href="#_2-3-1-什么是数据卷" aria-hidden="true">#</a> 2.3.1.什么是数据卷</h3><p>**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/578f9c52a8c44edbf684b34c4a4524b9.png" alt="image-20210731173541846" tabindex="0" loading="lazy"><figcaption>image-20210731173541846</figcaption></figure><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的<code>/var/lib/docker/volumes/html</code>目录，就等于操作容器内的<code>/usr/share/nginx/html</code>目录了</p><h3 id="_2-3-2-数据集操作命令" tabindex="-1"><a class="header-anchor" href="#_2-3-2-数据集操作命令" aria-hidden="true">#</a> 2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><h3 id="_2-3-3-创建和查看数据卷" tabindex="-1"><a class="header-anchor" href="#_2-3-3-创建和查看数据卷" aria-hidden="true">#</a> 2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume create html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>② 查看所有数据</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/788ebfa96bb91499056c49280bab7157.png" alt="image-20210731173746910" tabindex="0" loading="lazy"><figcaption>image-20210731173746910</figcaption></figure><p>③ 查看数据卷详细信息卷</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume inspect html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/bfcfb543416cc53d75b310c59011848b.png" alt="image-20210731173809877" tabindex="0" loading="lazy"><figcaption>image-20210731173809877</figcaption></figure><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><p><mark>所以，<code>create</code>后，宿主机和数据卷是自动创建并挂载的。</mark></p><p><strong>小结</strong>：</p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><h3 id="_2-3-4-挂载数据卷" tabindex="-1"><a class="header-anchor" href="#_2-3-4-挂载数据卷" aria-hidden="true">#</a> 2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token punctuation">\\</span>
  <span class="token parameter variable">--name</span> mn <span class="token punctuation">\\</span>
  <span class="token parameter variable">-v</span> html:/root/html <span class="token punctuation">\\</span>
  <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80
  nginx <span class="token punctuation">\\</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/html</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li></ul><h3 id="_2-3-5-案例-给nginx挂载数据卷" tabindex="-1"><a class="header-anchor" href="#_2-3-5-案例-给nginx挂载数据卷" aria-hidden="true">#</a> 2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的HTML目录</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> mn <span class="token parameter variable">-v</span> html:/usr/share/nginx/html <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>② 进入html数据卷所在位置，并修改HTML内容</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看html数据卷的位置</span>
<span class="token function">docker</span> volume inspect html
<span class="token comment"># 进入该目录</span>
<span class="token builtin class-name">cd</span> /var/lib/docker/volumes/html/_data
<span class="token comment"># 修改文件</span>
<span class="token function">vi</span> index.html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/34b1773cfaa6a2afb5f10fcd7aa49088.png" alt="image-20230612150425281" tabindex="0" loading="lazy"><figcaption>image-20230612150425281</figcaption></figure><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/dc0d2545d1f5236bc53433240989a2c5.png" alt="image-20230612150507231" tabindex="0" loading="lazy"><figcaption>image-20230612150507231</figcaption></figure><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20241230105940213.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-3-6-小结" tabindex="-1"><a class="header-anchor" href="#_2-3-6-小结" aria-hidden="true">#</a> 2.3.6.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/09098db2bf525c7b06249a1aae4193c3.png" alt="image-20230612155530931" tabindex="0" loading="lazy"><figcaption>image-20230612155530931</figcaption></figure>`,65);function m(b,v){const i=d("ExternalLinkIcon");return c(),p("div",null,[t,e("p",null,[a("1）首先去镜像仓库搜索nginx镜像，比如"),e("a",o,[a("DockerHub"),s(i)]),a(":")]),g,e("p",null,[a("在浏览器访问自己的虚拟机地址，例如我的是："),e("a",u,[a("http://8.140.248.10"),s(i)]),a("，即可看到结果：")]),h])}const k=l(r,[["render",m],["__file","Docker Commands.html.vue"]]);export{k as default};
