const e=JSON.parse('{"key":"v-03599615","path":"/Java/collections/2.HashMap.html","title":"HashMap的原理","lang":"zh-CN","frontmatter":{"order":2,"author":null,"title":"HashMap的原理","category":["Java基础","集合"],"description":"JDK 1.7 中 HashMap 的数据结构是数组+`链表 JDK 8 中 HashMap 的数据结构是数组+链表+红黑树。 HashMap 使用键的 hashCode() 方法计算哈希值，并通过 indexFor 方法（JDK 1.7 及之后版本移除了这个方法，直接使用==数组大小n==(n - 1) & hash）确定元素在数组中的存储位置。哈希...","head":[["meta",{"property":"og:url","content":"https://tim-qtp.github.io/blog/blog/Java/collections/2.HashMap.html"}],["meta",{"property":"og:site_name","content":"Qtp"}],["meta",{"property":"og:title","content":"HashMap的原理"}],["meta",{"property":"og:description","content":"JDK 1.7 中 HashMap 的数据结构是数组+`链表 JDK 8 中 HashMap 的数据结构是数组+链表+红黑树。 HashMap 使用键的 hashCode() 方法计算哈希值，并通过 indexFor 方法（JDK 1.7 及之后版本移除了这个方法，直接使用==数组大小n==(n - 1) & hash）确定元素在数组中的存储位置。哈希..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-18T07:23:14.000Z"}],["meta",{"property":"article:author","content":"tim-qtp"}],["meta",{"property":"article:modified_time","content":"2025-03-18T07:23:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HashMap的原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-18T07:23:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"tim-qtp\\",\\"url\\":\\"https://github.com/tim-qtp/\\"}]}"]]},"headers":[{"level":3,"title":"HashMap 的红黑树优化：","slug":"hashmap-的红黑树优化","link":"#hashmap-的红黑树优化","children":[]},{"level":3,"title":"hashCode() 和 equals() 的重要性：","slug":"hashcode-和-equals-的重要性","link":"#hashcode-和-equals-的重要性","children":[]},{"level":3,"title":"默认容量与负载因子的选择：","slug":"默认容量与负载因子的选择","link":"#默认容量与负载因子的选择","children":[]},{"level":3,"title":"哈希冲突链表法图解","slug":"哈希冲突链表法图解","link":"#哈希冲突链表法图解","children":[]},{"level":3,"title":"rehashing 细节","slug":"rehashing-细节","link":"#rehashing-细节","children":[]},{"level":3,"title":"为什么hashmap扩容要用&运算？","slug":"为什么hashmap扩容要用-运算","link":"#为什么hashmap扩容要用-运算","children":[]},{"level":3,"title":"JDK 1.8 对 HashMap 除了红黑树还进行了哪些改动？","slug":"jdk-1-8-对-hashmap-除了红黑树还进行了哪些改动","link":"#jdk-1-8-对-hashmap-除了红黑树还进行了哪些改动","children":[]},{"level":3,"title":"hashmap，为什么线程不安全","slug":"hashmap-为什么线程不安全","link":"#hashmap-为什么线程不安全","children":[]},{"level":3,"title":"为什么 HashMap 在 Java 中扩容时采用 2 的 n 次方倍？","slug":"为什么-hashmap-在-java-中扩容时采用-2-的-n-次方倍","link":"#为什么-hashmap-在-java-中扩容时采用-2-的-n-次方倍","children":[]},{"level":3,"title":"Java 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别","slug":"java-中-concurrenthashmap-1-7-和-1-8-之间有哪些区别","link":"#java-中-concurrenthashmap-1-7-和-1-8-之间有哪些区别","children":[]}],"git":{"createdTime":1742282594000,"updatedTime":1742282594000,"contributors":[{"name":"tim-qtp","email":"2469100031@qq.com","commits":1}]},"readingTime":{"minutes":10.22,"words":3066},"filePathRelative":"Java/collections/2.HashMap.md","localizedDate":"2025年3月18日","autoDesc":true,"excerpt":""}');export{e as data};
