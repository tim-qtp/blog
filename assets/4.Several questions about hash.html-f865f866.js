import{_ as a,W as e,X as h,a2 as s}from"./framework-48328e23.js";const o={},n=s('<h3 id="_1、什么是hash算法" tabindex="-1"><a class="header-anchor" href="#_1、什么是hash算法" aria-hidden="true">#</a> 1、什么是hash算法：</h3><p>就是把任意长度的输入通过散列算法变成固定长度的输出，这个输出结果就是一个散列值；</p><h3 id="_2、hash表是什么" tabindex="-1"><a class="header-anchor" href="#_2、hash表是什么" aria-hidden="true">#</a> 2、hash表是什么：</h3><p>就是散列表，可以直接通过key访问到内存存储位置的数据结构。</p><h3 id="_3、hashmap和hashtable的区别" tabindex="-1"><a class="header-anchor" href="#_3、hashmap和hashtable的区别" aria-hidden="true">#</a> 3、hashmap和HashTable的区别：</h3><p>都是基于hash表实现的k-v结构的集合；</p><p>前者不安全，后者安全。</p><p>HashTable是jdk1.0引入的一个线程安全的集合类，因为所有数据访问的方法都加入了一个Synchronized同步锁，内部采用数组+链表结构，链表是为了解决hash冲突。</p><p>hashmap可以使用null作为key，而hashtable不允许；</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503172244978.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所以：</p><ul><li><strong>ConcurrentHashMap</strong> 是 <code>Hashtable</code> 的替代方案。它在实现线程安全的同时，通过<mark>分段锁</mark>机制提高了并发性能，避免了全局锁导致的性能瓶颈。适用于高并发环境。</li><li><code>ConcurrentHashMap</code> 的读操作无锁化，写操作则使用了局部锁分段，使得在高并发下性能大大优于 <code>Hashtable</code>。</li></ul><h3 id="_4、concurrenthashmap-和-hashtable-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_4、concurrenthashmap-和-hashtable-的区别是什么" aria-hidden="true">#</a> 4、ConcurrentHashMap 和 Hashtable 的区别是什么？</h3><p><strong>因为在线程安全性上的实现方式不同，导致了它们性能上的差别</strong>：</p><ul><li><strong><code>Hashtable</code></strong>：<code>Hashtable</code> 使用的是单一的锁机制（全表锁），即对整个哈希表进行同步，所有的操作（如插入、删除、查找等）都必须通过一个锁（synchronized）来保证线程安全。这种方式使得 <code>Hashtable</code> 在多线程环境下效率较低，因为无论是读取还是写入操作都需要获得锁，无法做到并发访问。</li><li><strong><code>ConcurrentHashMap</code></strong>：在 Java 8 中，<code>ConcurrentHashMap</code> 采用了 <code>CAS + synchronized</code> 的方式进行线程安全控制。CAS 用于无锁的写入操作。如果某个 Node 节点为空，则通过 CAS 将数据插入节点。如果不为空，则会退化到 synchronized。使用 synchronized 锁定冲突节点的头结点。这种锁的粒度更细，仅锁住特定的冲突节点，而非整个表，因此在并发访问时性能较好。高的并发性能。</li></ul>',15),r=[n];function t(c,d){return e(),h("div",null,r)}const l=a(o,[["render",t],["__file","4.Several questions about hash.html.vue"]]);export{l as default};
