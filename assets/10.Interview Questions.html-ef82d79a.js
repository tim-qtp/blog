import{_ as a,W as i,X as e,a2 as r}from"./framework-48328e23.js";const l={},t=r('<h3 id="_1、rocketmq消费后会删除消息吗" tabindex="-1"><a class="header-anchor" href="#_1、rocketmq消费后会删除消息吗" aria-hidden="true">#</a> 1、rocketMQ消费后会删除消息吗？</h3><p>🎄不会，因为我们消息会持久化在我们硬盘中；</p><h3 id="_2、平时哪些地方用过mq" tabindex="-1"><a class="header-anchor" href="#_2、平时哪些地方用过mq" aria-hidden="true">#</a> 2、平时哪些地方用过MQ？</h3><ol><li>使用 mq 异步发送优惠券；</li><li>使用 mq 异步发送短信；</li><li>使用 mq 异步扣库存 总之将执行比较耗时的代码操作，交给 mq 异步实现接口</li></ol><h3 id="_3、如何保证rocketmq的高可用" tabindex="-1"><a class="header-anchor" href="#_3、如何保证rocketmq的高可用" aria-hidden="true">#</a> 3、如何保证RocketMQ的高可用？</h3><ul><li>集群部署：broker提供负载均衡</li><li>主从同步：进行数据冗余</li><li>故障转移（主→从；nameserver→nameserver）</li></ul><h3 id="_4、mq与多线程实现异步的区别" tabindex="-1"><a class="header-anchor" href="#_4、mq与多线程实现异步的区别" aria-hidden="true">#</a> 4、MQ与多线程实现异步的区别？</h3><ol><li>多线程方式实现异步可能会消耗到我们的 cpu 资源，会发生 cpu 竞争的问题；</li><li>MQ 方式实现异步是完全解耦，适合于大型互联网项目；</li><li>小的项目可以使用多线程实现异步，大项目建议使用 MQ 实现异步；</li></ol><h3 id="_5、mq-如何避免消息堆积的问题" tabindex="-1"><a class="header-anchor" href="#_5、mq-如何避免消息堆积的问题" aria-hidden="true">#</a> 5、MQ 如何避免消息堆积的问题？</h3><p>事前预估 k8s，消费者扩容， 消费者应该批量形式获取消息 减少网络传输的次数， 调整消息存储级别，对某些不那么重要的日志信息，可以选择不进行持久化处理，或者降低其优先级。</p><h3 id="_6、生产者投递消息-mq-宕机了如何处理" tabindex="-1"><a class="header-anchor" href="#_6、生产者投递消息-mq-宕机了如何处理" aria-hidden="true">#</a> 6、生产者投递消息，mq 宕机了如何处理?</h3><p>生产者投递消息会将 msg 消息内容记录下来（放到Redis/Mysq中），后续可以根据该日志记录实现补偿机制；</p><h3 id="_7、为什么要保留消息不删除呢" tabindex="-1"><a class="header-anchor" href="#_7、为什么要保留消息不删除呢" aria-hidden="true">#</a> 7、为什么要保留消息不删除呢</h3><p>因为某些情况下需要消息回溯或者故障恢复，然后将offset回溯到早期的消息哪里重新消费</p><h3 id="_8、为什么选rocketmq" tabindex="-1"><a class="header-anchor" href="#_8、为什么选rocketmq" aria-hidden="true">#</a> 8、为什么选RocketMQ</h3><p>可靠性高（双11已经经历了多次考验），高性能，低延迟，吞吐量也高；</p><p>为啥不用kafka呢？ kafka功能比较单一</p><ul><li>Kafka 不支持广播消息。</li><li>Kafka 不支持延时消息。</li><li>Kafka 不支持事务消息。</li><li>也会存在宕机后消息乱序的问题。</li></ul><h3 id="_9、如何设计一个mq" tabindex="-1"><a class="header-anchor" href="#_9、如何设计一个mq" aria-hidden="true">#</a> 9、如何设计一个MQ</h3><ol><li>实现一个单机的队列数据结构，高效，可扩展；</li><li>将单机队列扩展为分布式集群队列</li><li>基于Topic定制消息路由策略</li><li>实现高效的网络通信，Netty，Http</li><li>实现文件高效读写，零拷贝，顺序写；日志文件，服务重启启后，快速还原。</li><li>定制高级功能，死信队列，延迟消息，事务消息，贴合实际，随意发挥。</li></ol><h3 id="_10、什么是零拷贝" tabindex="-1"><a class="header-anchor" href="#_10、什么是零拷贝" aria-hidden="true">#</a> 10、什么是零拷贝？</h3><p>以前：硬件→内核→用户→内核→硬件，4次上下文切换，4次拷贝；</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503091443461.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>现在：内核→用户，不直接拷贝，而是通过映射，直接在内核空间中直接拷贝；4次上下文切换，3次拷贝；</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503091456858.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>还有，sendfile形式的零拷贝，它是linux内核2.1版本，提供的一个系统调用函数，专门发送文件的。</p><p>减少了两次用户态和内核态的切换；2次上下文切换，3次拷贝；</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503091507494.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',28),h=[t];function n(d,c){return i(),e("div",null,h)}const s=a(l,[["render",n],["__file","10.Interview Questions.html.vue"]]);export{s as default};
