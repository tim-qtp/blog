import{_ as s,W as n,X as a,a2 as e}from"./framework-48328e23.js";const o={},t=e(`<h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> <img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/0d2070e8f84c4801adbfa03bda1f98d9.png" style="zoom:50%;"></h3><p>首先客户端通过<strong>连接器和mysql相连</strong>，连接器用来验证连接，维持连接和管理连接，如果是一条查询语句，首先还会查询缓存，但是任何的更新操作都会导致缓存失效。效率的提升并不高，所以这个功能一般都被我们给关闭了。8.0之后直接就被弃用了。</p><hr><p>接着还会进行<strong>词法分析和语法分析</strong>，这和java的前端编译差不多，一般一个语句如果错了，那在这个阶段就能看到这样的提示</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> elect <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

ERROR <span class="token number">1064</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: You have an error <span class="token operator">in</span> your <span class="token keyword">SQL</span> syntax<span class="token punctuation">;</span> <span class="token keyword">check</span> the manual that corresponds <span class="token keyword">to</span> your MySQL server version <span class="token keyword">for</span> the <span class="token keyword">right</span> syntax <span class="token keyword">to</span> <span class="token keyword">use</span> near <span class="token string">&#39;elect * from t where ID=1&#39;</span> at line <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p><strong>优化器</strong>是一个重头戏，选出最适合的查询索引连接顺序等，并且在这个阶段还会生成具体的执行计划</p><p>具体如下：</p><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。优化器的作用是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><p>比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">join</span> t2 <span class="token keyword">using</span><span class="token punctuation">(</span>department_id<span class="token punctuation">)</span> <span class="token keyword">where</span> t1<span class="token punctuation">.</span>c<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">and</span> t2<span class="token punctuation">.</span>d<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>既可以先从表 t1 里面取出 <code>c=10</code> 的记录的 department_id值，再根据 department_id值关联到表 t2，再判断 t2 里面 <code>d</code> 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 <code>d=20</code> 的记录的 department_id值，再根据 department_id值关联到 t1，再判断 t1 里面 <code>c</code> 的值是否等于 10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>可能这么判断：如果表t1比较小，那么就先用第一个，反之用第二个。</p><hr><p><strong>执行器</strong>就会根据执行计划无脑的操作就好了</p><hr><p>mysql的<strong>存储引擎是一个可插拔的设计</strong>，可以用InnoDB，也可以用MyISAM，server层统一定义了一套api，不同的存储引擎一一的去实现就好了，比如这样一条查询语句：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> T <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行器就会：</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol>`,21),p=[t];function r(l,c){return n(),a("div",null,p)}const i=s(o,[["render",r],["__file","4.The execution process of a SQL statement.html.vue"]]);export{i as default};
