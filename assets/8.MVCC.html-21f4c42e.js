import{_ as l,W as e,X as i,a2 as o}from"./framework-6a3aa88c.js";const a={},d=o('<p>MVCC 指的是多版本并发控制，是一种并发控制机制。简单来说，就是给我们的 MySQL 数据拍个“快照”，定格某个时刻数据库的状态。允许多个事务同时读取和写入数据库，而无需互相等待，从而提高数据库的并发性能。</p><p>在 MySQL 中，MVCC 是通过<mark>隐藏字段</mark>，<mark>undo log版本链</mark>和 <mark>ReadView</mark> 机制来实现的。</p><p>多版本：指mysql维护着行数据的多个版本</p><p>并发控制：在多个事务同时操作某一行记录时mysql控制返回多个版本的行记录中的某个版本。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503181216266.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_1-隐藏字段-每条记录的小秘密" tabindex="-1"><a class="header-anchor" href="#_1-隐藏字段-每条记录的小秘密" aria-hidden="true">#</a> <strong>1. 隐藏字段：每条记录的小秘密</strong></h3><ul><li><strong>DB_TRX_ID</strong>：记录最后一次修改这条数据的事务 ID。 <ul><li>比如事务 A 修改了这条数据，那么这条数据的 <code>DB_TRX_ID</code> 就是事务 A 的 ID。</li></ul></li><li><strong>DB_ROLL_PTR</strong>：指向这条数据的旧版本（历史版本）的指针。 <ul><li>比如事务 A 修改了数据，旧版本的数据会被存到 Undo Log 里，<code>DB_ROLL_PTR</code> 就是指向这个旧版本的“地址”。</li></ul></li></ul><h3 id="_2-undo-log-版本链-数据的时光机" tabindex="-1"><a class="header-anchor" href="#_2-undo-log-版本链-数据的时光机" aria-hidden="true">#</a> <strong>2. Undo Log 版本链：数据的时光机</strong></h3><ul><li>每次修改数据时，MySQL 不会直接覆盖旧数据，而是把旧数据存到一个叫 <strong>Undo Log</strong> 的地方。</li><li>这些旧数据通过 <code>DB_ROLL_PTR</code> 连成一条链，就像一个时光机，可以找到这条数据的所有历史版本。</li><li>比如： <ul><li>事务 A 把 <code>balance</code> 从 1000 改成 900，<mark>旧版本 1000</mark> 被存到 Undo Log。</li><li>事务 B 又把 <code>balance</code> 从 900 改成 800，<mark>旧版本 900</mark> 也被存到 Undo Log。</li><li>这时候，<code>DB_ROLL_PTR</code> 就指向了一个版本链：800 → 900 →1000。</li></ul></li></ul><h3 id="_3-readview-决定你能看到什么" tabindex="-1"><a class="header-anchor" href="#_3-readview-决定你能看到什么" aria-hidden="true">#</a> <strong>3. ReadView：决定你能看到什么</strong></h3><ul><li>当一个事务想读数据时，MySQL 会为它创建一个 <strong>ReadView</strong>。</li><li>ReadView 就像是一个“快照”，决定了这个事务能看到哪些数据版本。</li><li>ReadView 包含以下信息： <ul><li><strong>活跃事务列表</strong>：当前正在运行的事务 ID。</li><li><strong>最小事务 ID</strong>：当前系统中最老的事务 ID。</li><li><strong>最大事务 ID</strong>：当前系统中最新的事务 ID（：事务 ID 的最大值加一。换句话说，它是下一个将要生成的事务 ID）。</li><li><strong>创建者事务 ID</strong>：创建这个 ReadView 的事务 ID。</li></ul></li></ul><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503181219982.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>用一个例子来说明整个过程：</p><h4 id="场景" tabindex="-1"><a class="header-anchor" href="#场景" aria-hidden="true">#</a> <strong>场景</strong></h4><ul><li>表 <code>users</code> 中有一条数据：<code>id=1, name=&#39;Alice&#39;, balance=1000</code>。</li><li>事务 A（ID=100）把 <code>balance</code> 从 1000 改成 900。</li><li>事务 B（ID=101）想读取 <code>balance</code> 的值。</li></ul><h4 id="步骤-1-事务-a-修改数据" tabindex="-1"><a class="header-anchor" href="#步骤-1-事务-a-修改数据" aria-hidden="true">#</a> <strong>步骤 1：事务 A 修改数据</strong></h4><ul><li>事务 A 把 <code>balance</code> 从 1000 改成 900。</li><li>MySQL 做了两件事： <ol><li>把旧数据 <code>balance=1000</code> 存到 Undo Log。</li><li>更新当前数据的 <code>DB_TRX_ID=100</code>（事务 A 的 ID），<code>DB_ROLL_PTR</code> 指向 Undo Log 中的旧版本(1000)。</li></ol></li></ul><h4 id="步骤-2-事务-b-读取数据" tabindex="-1"><a class="header-anchor" href="#步骤-2-事务-b-读取数据" aria-hidden="true">#</a> <strong>步骤 2：事务 B 读取数据</strong></h4><ul><li>事务 B 想读取 <code>balance</code> 的值。</li><li>MySQL 为事务 B 创建一个 ReadView： <ul><li>活跃事务列表：<code>[100]</code>（事务 A 还在运行）。</li><li>最小事务 ID：100。</li><li>最大事务 ID：101。</li><li>创建者事务 ID：101（事务 B 的 ID）。</li></ul></li><li>事务 B 开始读取数据： <ol><li>检查当前数据的 <code>DB_TRX_ID=100</code>。</li><li>判断 <code>DB_TRX_ID</code> 是否可见： <ul><li>如果 <code>DB_TRX_ID</code> 小于最小事务 ID（100 &lt; 100？不成立），说明数据是事务 B 开始之前提交的，可见。</li><li>如果 <code>DB_TRX_ID</code> 在活跃事务列表中（100 在 <code>[100]</code> 中），说明数据是未提交的，不可见。</li><li>如果 <code>DB_TRX_ID</code> 大于等于最大事务 ID（100 &gt;= 101？不成立），说明数据是事务 B 开始之后创建的，不可见。</li></ul></li><li>发现 <code>DB_TRX_ID=100</code> 在活跃事务列表中，说明数据是未提交的，不可见。</li><li>通过 <code>DB_ROLL_PTR</code> 找到旧版本的数据 <code>balance=1000</code>，返回给事务 B。</li></ol></li></ul><h4 id="步骤-3-事务-a-提交" tabindex="-1"><a class="header-anchor" href="#步骤-3-事务-a-提交" aria-hidden="true">#</a> <strong>步骤 3：事务 A 提交</strong></h4><ul><li>事务 A 提交后，数据的 <code>DB_TRX_ID=100</code> 变成已提交状态。</li><li>如果事务 B 再次读取数据： <ul><li>检查 <code>DB_TRX_ID=100</code>，发现它不在活跃事务列表中，说明数据已提交，可见。</li><li>直接返回当前数据 <code>balance=900</code>。</li></ul></li></ul>',21),c=[d];function n(r,t){return e(),i("div",null,c)}const g=l(a,[["render",n],["__file","8.MVCC.html.vue"]]);export{g as default};
