import{_ as e,W as n,X as a,a2 as r}from"./framework-48328e23.js";const p={},i=r('<h3 id="容器概念、控制反转、依赖注入" tabindex="-1"><a class="header-anchor" href="#容器概念、控制反转、依赖注入" aria-hidden="true">#</a> 容器概念、控制反转、依赖注入</h3><p>ioc容器：实际上就是个map(key，value)，里面存的是各种对象</p><p>定义 Spring Bean 的方式：</p><ul><li><strong>XML 配置</strong>：早期的 Spring 应用通常通过 XML 文件定义 Bean，使用 <code>&lt;bean&gt;</code> 标签来指定类、构造器参数和依赖关系。Spring Boot 项目已经不怎么用了。</li><li><strong>基于注解的配置</strong>：使用 @Component、@Service、@Repository、@Controller 等注解可以将类标记为 Spring Bean，Spring 会自动扫描这些类并将其注册为 Bean。</li><li><strong>Java 配置类</strong>：通过 @Configuration 和 @Bean 注解，可以在 Java 类中手动定义 Bean。相比 XML 配置，这种方式更加简洁和类型安全。</li></ul><p>在项日启动的时候会读取这些bean节点，根据全限定类名使用反射创建对象放到<mark>map</mark>里。</p><p>这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入(@Autowired、@Resource等注解)。</p><h3 id="控制反转" tabindex="-1"><a class="header-anchor" href="#控制反转" aria-hidden="true">#</a> 控制反转:</h3><p>（ 1 ）是指创建对象的控制权的转移，以前是由你控制，现在由spring管理；并由容器根据配置文件或注解使用java的反射机制去创建实例和管理各个实例之间的依赖关系。</p><p>（ 2）容器：上面说的就是容器！</p><p>（ 3 ）Spring 的 IOC 有三种注入方式 ：构造器注入、setter 方法注入、根据注解注入。</p><h3 id="ioc有什么好处" tabindex="-1"><a class="header-anchor" href="#ioc有什么好处" aria-hidden="true">#</a> IOC有什么好处？</h3><p>在平时的 Java 开发中，如果我们要实现某一个功能，可能至少需要两个以上的对象来协助完成，在没有 Spring 之前，每个对象在需要它的合作对象时，需要自己 new 一个，比如说 A 要使用 B，A 就对 B 产生了依赖，也就是 A 和 B 之间存在了一种耦合关系。</p><p>有了 Spring 之后，就不一样了，创建 B 的工作交给了 Spring 来完成，Spring 创建好了 B 对象后就放到容器中，A 告诉 Spring 我需要 B，Spring 就从容器中取出 B 交给 A 来使用。</p><p>至于 B 是怎么来的，A 就不再关心了，Spring 容器想通过 newnew 创建 B 还是 new 创建 B，无所谓。</p><p>这就是 IoC 的好处，它降低了对象之间的耦合度，使得程序更加灵活，更加易于维护。</p><p>Spring 倡导的开发方式就是所有类的创建和销毁都通过 Spring 容器来，不再是开发者去 new，去 <code>= null</code>，这样就实现了对象的解耦。</p><p>bean的生命周期完全由Spring控制，解放双手！</p>',17),o=[i];function t(c,s){return n(),a("div",null,o)}const l=e(p,[["render",t],["__file","3.IOC.html.vue"]]);export{l as default};
