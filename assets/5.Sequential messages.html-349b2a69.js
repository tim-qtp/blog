import{_ as n,W as s,X as a,a2 as t}from"./framework-6a3aa88c.js";const p={},e=t(`<p>常见方法：</p><p><strong>单一生产者和单一消费者</strong>：</p><ul><li>使用单个生产者发送消息到<strong>单个队列</strong>，并由单个消费者处理消息。这样可以确保消息按照生产者的发送顺序消费。</li><li>这种方法简单但容易成为<strong>性能瓶颈</strong>，无法充分利用并发的优势。</li></ul><p><strong>分区与顺序键（Partition Key）</strong>：</p><ul><li>在支持<strong>分区（Partition）</strong> 的消息队列中（如 <mark>Kafka、RocketMQ</mark>），可以通过 <strong>Partition Key</strong> 将消息发送到特定的分区。每个分区内部是<strong>有序的</strong>，这样可以保证相同 Partition Key 的消息按顺序消费。</li><li>例如，在订单处理系统中，可以使用订单号作为 Partition Key，将同一个订单的所有消息路由到同一个分区，确保该订单的消息顺序。</li></ul><p><strong>顺序队列（Ordered Queue）</strong>：</p><ul><li>一些消息队列系统（如 RabbitMQ）支持顺序队列，消息在队列中的存储顺序与投递顺序一致。<strong>如果使用单个顺序队列</strong>，消息将按顺序被消费。</li><li>可以使用多个顺序队列来提高并发处理能力，并使用特定规则将消息分配到不同的顺序队列中。</li></ul><p><strong>还有一个概念叫全部消息和局部消息：</strong></p><p>如果要保证消息的<strong>全局有序</strong>，首先只能由一个生产者往 Topic 发送消息，并且一个 Topic 内部只能有一个队列（分区）。消费者也必须是单线程消费这个队列。这样的消息就是全局有序的！</p><p>不过一般情况下我们都不需要全局有序，即使是同步 MySQL Binlog 也只需要保证<strong>单表</strong>消息有序即可。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503091204593.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>绝大部分的有序需求是<strong>部分有序</strong>，部分有序我们就可以将 Topic 内部划分成我们需要的队列数，把消息通过特定的策略发往固定的队列中，然后每个队列对应一个<mark>单线程</mark>处理的消费者。</p><p>例如同一个订单或用户的消息按顺序消费，而不同订单或用户之间的顺序不做保证。</p><p>这样即完成了部分有序的需求，又可以通过队列数量的并发来提高消息处理效率。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503091204128.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后，在 <strong>RocketMQ</strong> 中，可以通过<strong>消息队列选择器</strong>（<code>MessageQueueSelector</code>）将消息发送到指定的队列，从而实现顺序消费。</p><p><strong>生产者代码</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> orderId <span class="token operator">=</span> <span class="token string">&quot;order-123&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> body <span class="token operator">=</span> <span class="token string">&quot;Order Step &quot;</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">&quot; for &quot;</span> <span class="token operator">+</span> orderId<span class="token punctuation">;</span>
    <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;OrderTopic&quot;</span><span class="token punctuation">,</span> body<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用 MessageQueueSelector 按照 orderId 选择队列</span>
    <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueueSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token doc-comment comment">/**
            mqs：当前 OrderTopic 中所有的消息队列。
            msg：当前要发送的消息。
            arg：传入的参数（这里是 orderId），用来选择目标队列。
        */</span>
        <span class="token keyword">public</span> <span class="token class-name">MessageQueue</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageQueue</span><span class="token punctuation">&gt;</span></span> mqs<span class="token punctuation">,</span> <span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 将 orderId 转为 hash 值，以决定消息发往哪个队列</span>
            <span class="token class-name">String</span> orderId <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> arg<span class="token punctuation">;</span>
            <span class="token keyword">int</span> index <span class="token operator">=</span> orderId<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> mqs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> mqs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取绝对值，避免负索引。</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>消费者代码</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 使用并发消费消息监听器，保证单队列内的顺序性</span>
consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>msgs<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg <span class="token operator">:</span> msgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> body <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Consumed message: %s from queue: %d\\n&quot;</span><span class="token punctuation">,</span> body<span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span><span class="token constant">CONSUME_SUCCESS</span><span class="token punctuation">;</span> <span class="token comment">//消费成功</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>这里虽然<code>MessageListenerConcurrently</code>是并发监听，但是</p><p>RocketMQ 会为每个队列分配独立的线程。</p><p>不同队列之间的消费是并发的，但同一个队列内仍然按顺序消费。</p><p>所以这里的msgs是一次性接收的消息列表（RocketMQ 支持批量消费）</p></div>`,21),o=[e];function c(l,i){return s(),a("div",null,o)}const r=n(p,[["render",c],["__file","5.Sequential messages.html.vue"]]);export{r as default};
