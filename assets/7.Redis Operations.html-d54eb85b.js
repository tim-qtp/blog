import{_ as l,W as s,X as d,$ as e,a1 as i,Z as t,a2 as a,C as o}from"./framework-48328e23.js";const n={},h=a('<h2 id="redis-报内存不足怎么处理" tabindex="-1"><a class="header-anchor" href="#redis-报内存不足怎么处理" aria-hidden="true">#</a> Redis 报内存不足怎么处理？</h2><p>Redis 内存不足有这么几种处理方式：</p><ul><li>修改配置文件 redis.conf 的 maxmemory 参数，增加 Redis 可用内存</li><li>也可以通过命令 set maxmemory 动态设置内存上限</li><li>修改内存淘汰策略，及时释放内存空间</li><li>使用 Redis 集群模式，进行横向扩容。</li></ul><h2 id="redis-key-过期策略有哪些我" tabindex="-1"><a class="header-anchor" href="#redis-key-过期策略有哪些我" aria-hidden="true">#</a> Redis key 过期策略有哪些我？</h2><p>惰性删除和定期删除。</p><p>惰性删除：当某个键被访问时，如果发现它已经过期，Redis 会立即删除该键；但这也意味着如果一个已过期的键从未被访问，它就不会被删除，会占用额外的内存空间。</p><p>定期删除：每隔一段时间，Redis 就会随机检查一些键是否过期，如果过期就删除。</p><h2 id="内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#内存淘汰策略" aria-hidden="true">#</a> 内存淘汰策略？</h2><ol><li>noeviction：默认策略，不进行任何数据淘汰，直接返回错误信息。</li><li>allkeys-lru：从所有键中，使用 LRU 算法淘汰最近最少使用的键。</li><li>allkeys-lfu：从所有键中，使用 LFU 算法淘汰最少使用的键。</li><li>volatile-lru：从设置了过期时间的键中淘汰最近最少使用的键。</li><li>volatile-ttl：从设置了过期时间的键中淘汰即将过期的键。</li></ol><h4 id="lru-和-lfu-的区别是什么" tabindex="-1"><a class="header-anchor" href="#lru-和-lfu-的区别是什么" aria-hidden="true">#</a> LRU 和 LFU 的区别是什么？</h4><p>LRU（Least Recently Used）：基于时间维度，淘汰最近最少访问的键。适合访问具有时间特性的场景。</p><p>LFU（Least Frequently Used）：基于次数维度，淘汰访问频率最低的键。更适合长期热点数据场景。</p><h2 id="大-key-问题" tabindex="-1"><a class="header-anchor" href="#大-key-问题" aria-hidden="true">#</a> 大 key 问题</h2><p>&quot;big Key&quot;是指一个内存空间占用比较大的键(Key)</p><ul><li><strong>内存压力</strong>，内存分布不均。在集群模式下，不同slot分配到不同实例中，如果大ky都映射到一个实例，则分布不均，查询效率也会受到影响。</li><li>由于Redis单线程执行命令，操作<strong>大Key时耗时较长</strong>，从而导致Redis出现其它命令阻塞的问题。</li><li>大key对<strong>资源的占用巨大</strong>，在你进行网络I/O传输的时候，导致你获取过程中产生的网络流量较大，从而产生网络传输时间延长甚至网络传输发现阻塞的现象，例如一个key 2MB,请求个1000次2000MB。</li><li><strong>客户端超时</strong>。因为操作大key时耗时较长，可能导致客户端等待超时。</li></ul><p>如何找到大 key?</p><p>①、bigkeys 参数：使用 bigkeys 命令以遍历的方式分析 Redis 实例中的所有 Key，并返回整体统计信息与每个数据类型中 Top1 的大 Key</p><blockquote><p>bigkeys 命令的使用：<code>redis-cli --bigkeys</code></p></blockquote><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/redis-20240309091503.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>②、redis-rdb-tools：redis-rdb-tools 是由 Python 语言编写的用来分析 Redis 中 rdb 快照文件的工具。</p>',20),c={href:"https://github.com/sripathikrishnan/redis-rdb-tools/",target:"_blank",rel:"noopener noreferrer"},p=a('<p>怎么解决：</p><ol><li>大key→小key，对于数据过大的<code>ZSet</code>可以分页查询</li><li>定期清理大 Key，对于<strong>不重要的大 Key</strong>，可以设置较短的过期时间；删除大 Key 时，使用使用 <code>UNLINK</code>异步删除，而不是 <code>DEL</code></li><li>搭建redis集群，把key分配到不同的hash slot槽所在的分片上</li></ol><h2 id="redis如何判断某个key应该在哪个实例" tabindex="-1"><a class="header-anchor" href="#redis如何判断某个key应该在哪个实例" aria-hidden="true">#</a> Redis如何判断某个key应该在哪个实例？</h2><ul><li>将16384个插槽分配到不同的实例</li><li>根据key的有效部分计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><h2 id="数据key不是与节点绑定-而是与插槽绑定" tabindex="-1"><a class="header-anchor" href="#数据key不是与节点绑定-而是与插槽绑定" aria-hidden="true">#</a> 数据key不是与节点绑定，而是与插槽绑定</h2><p>插槽可以集体转换，它与节点是绑定的关系，节点宕机了，还可以将插槽绑定到到别的节点上；如果和节点绑定的话，节点宕机了，你还得重新配置节点或手动迁移大量数据；</p><h2 id="为什么redis要选择单线程" tabindex="-1"><a class="header-anchor" href="#为什么redis要选择单线程" aria-hidden="true">#</a> 为什么Redis要选择单线程</h2><ul><li>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li></ul>',8);function y(u,k){const r=o("ExternalLinkIcon");return s(),d("div",null,[h,e("p",null,[i("源码地址："),e("a",c,[i("https://github.com/sripathikrishnan/redis-rdb-tools/"),t(r)])]),p])}const b=l(n,[["render",y],["__file","7.Redis Operations.html.vue"]]);export{b as default};
