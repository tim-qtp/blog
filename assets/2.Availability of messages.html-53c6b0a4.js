import{_ as a,W as e,X as r,a2 as t}from"./framework-28eb7fba.js";const i={},o=t('<p>消息可能在哪些阶段丢失呢？可能会在这三个阶段发生丢失：生产阶段、存储阶段、消费阶段。</p><p>所以要从这三个阶段考虑：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503082022513.jpeg" alt="消息传递三阶段" tabindex="0" loading="lazy"><figcaption>消息传递三阶段</figcaption></figure><h5 id="生产" tabindex="-1"><a class="header-anchor" href="#生产" aria-hidden="true">#</a> 生产</h5><p>在生产阶段，主要<strong>通过请求确认机制，来保证消息的可靠传递</strong>。</p><p>生产者发送消息至 Broker ，需要处理 Broker 的响应，不论是同步还是异步发送消息，同步和异步回调都需要做好 try-catch ，妥善的处理响应，如果 Broker 返回写入失败等错误消息，需要重试发送。当多次发送失败需要作报警，日志记录等。</p><p>这样就能保证在生产消息阶段消息不会丢失。</p><h5 id="存储" tabindex="-1"><a class="header-anchor" href="#存储" aria-hidden="true">#</a> 存储</h5><p>存储消息阶段需要在<strong>消息刷盘</strong>之后再给生产者响应，假设消息写入缓存中就返回响应，那么机器突然断电这消息就没了，而生产者以为已经发送成功了。</p><p>如果 Broker 是集群部署，有多副本机制，即消息不仅仅要写入当前 Broker，还需要写入副本机中。可以配置成至少写入两台机子后再给生产者响应，这样基本上就能保证存储的可靠了。</p><h5 id="消费" tabindex="-1"><a class="header-anchor" href="#消费" aria-hidden="true">#</a> 消费</h5><p>从 Consumer 角度分析，如何保证消息被成功消费？</p><ul><li>Consumer 保证消息成功消费的关键在于确认的时机，<mark>不要</mark>在收到消息后就<mark>立即发送消费确认</mark>，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。因为消息队列维护了消费的位置，如果机子崩了，逻辑执行失败了，没有确认，再去队列拉取消息，就还是之前的一条。</li></ul>',13),s=[o];function n(c,h){return e(),r("div",null,s)}const d=a(i,[["render",n],["__file","2.Availability of messages.html.vue"]]);export{d as default};
