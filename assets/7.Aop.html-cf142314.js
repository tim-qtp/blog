import{_ as n,W as s,X as a,a2 as t}from"./framework-6a3aa88c.js";const p={},e=t(`<h3 id="_1、基础概念" tabindex="-1"><a class="header-anchor" href="#_1、基础概念" aria-hidden="true">#</a> 1、基础概念：</h3><p>aop就是面向切面编程，它是为了解耦而生的；我们在做业务逻辑代码开发的时候，可以在不改动原本代码的前提下，进行植入。</p><p>减少重复代码，抽取公共方法，每次调用方法前自动调用；</p><p>就像大楼，有主体，楼梯，电梯等；但是为了提高安全性和舒适性吧，加入了防火系统，中央空调和网络基础设施。都可以在原来基础上添加功能。</p><p>在平时开发中主要用于<mark>日志，权限控制，事务管理，统一异常处理</mark>。</p><p>实现方式：动态代理，其实就是夹带私活。</p><p><mark>具体怎么写</mark>：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503071815731.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="aop-的核心概念" tabindex="-1"><a class="header-anchor" href="#aop-的核心概念" aria-hidden="true">#</a> AOP 的核心概念</h3><p>直接用代码解释吧</p><p>首先，定义一个简单的服务类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;创建用户：&quot;</span> <span class="token operator">+</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，定义一个切面，用于在方法执行前后记录日志：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">ProceedingJoinPoint</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Around</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Aspect</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">&quot;execution(* UserService.*(..))&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">logAround</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;方法开始执行：&quot;</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;方法执行结束：&quot;</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//还可以这么定义切入点</span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">&quot;execution(* UserService.*(..))&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inUserService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中：</p><ul><li><strong>切面（Aspect）</strong>：<code>LoggingAspect</code> 类通过 <code>@Aspect</code> 注解定义为一个切面。</li><li><strong>切入点（Pointcut）</strong>：<code>@Around(&quot;execution(* UserService.*(..))&quot;)</code> 定义了一个切入点，表示匹配 <code>UserService</code> 类中所有方法的执行。</li><li><strong>通知（Advice）</strong>：<code>logAround</code> 方法是一个环绕通知，在匹配的连接点前后执行。</li><li><strong>连接点（Join Point）</strong>：<code>UserService</code> 类中的每个方法执行都是一个连接点。</li><li><strong>目标对象（Target Object）</strong>：<code>UserService</code> 类的实例是目标对象。</li><li><strong>织入（Weaving）</strong>：在运行时，AOP 框架将 <code>LoggingAspect</code> 切面织入到 <code>UserService</code> 的方法调用中。</li></ul><h3 id="spring-aop默认用的是什么动态代理-两者的区别" tabindex="-1"><a class="header-anchor" href="#spring-aop默认用的是什么动态代理-两者的区别" aria-hidden="true">#</a> Spring AOP默认用的是什么动态代理，两者的区别？</h3><p>Spring Framework 默认使用的动态代理是 JDK 动态代理，SpringBoot 2.x 版本的默认动态代理是 CGLIB。</p><p>为什么使用CGLIB呢，因为使用JDK动态代理时，没有接口会报错，虽然效果差不多，但是CGLIB更方便</p><ul><li><p>JDK动态代理只能代理实现了接口的类。它通过反射机制在运行时创建一个实现了指定接口的代理对象</p></li><li><p>CGLIB通过生成目标类的子类来实现代理，因此可以代理没有实现接口的类。CGLIB的性能通常优于JDK动态代理，因为它是通过字节码生成的，避免了反射的开销，CGLIB不能代理final类和final方法，因为它无法继承这些类和方法</p></li></ul><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3>`,21),o=[e];function c(i,l){return s(),a("div",null,o)}const r=n(p,[["render",c],["__file","7.Aop.html.vue"]]);export{r as default};
