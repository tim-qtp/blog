import{_ as n,W as s,X as a,a2 as e}from"./framework-48328e23.js";const o={},t=e(`<h3 id="_1、myisam-和-innodb-实现-b-树索引方式的区别是什么" tabindex="-1"><a class="header-anchor" href="#_1、myisam-和-innodb-实现-b-树索引方式的区别是什么" aria-hidden="true">#</a> 1、MyISAM 和 InnoDB 实现 B 树索引方式的区别是什么？</h3><ul><li>InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身，其数据文件本身就是索引文件。</li><li>MyISAM 存储引擎：引文件和数据文件是分离的，叶子节点保存数据的物理地址。</li></ul><p>其他区别呢？</p><table><thead><tr><th>特性</th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td><strong>事务支持</strong></td><td>❌ 不支持事务</td><td>✅ 支持 ACID <strong>事务</strong></td></tr><tr><td><strong>外键支持</strong></td><td>❌ 不支持外键</td><td>✅ 支持<strong>外键</strong></td></tr><tr><td><strong>锁机制</strong></td><td><strong>表级锁</strong>（并发性能低）</td><td><strong>行级锁</strong>（并发性能高）</td></tr><tr><td><strong>查询性能</strong></td><td><strong>读性能较快</strong>，适合大量 <code>SELECT</code> 查询</td><td><strong>读写性能均衡</strong>，适合 <code>INSERT/UPDATE/DELETE</code></td></tr><tr><td><strong>崩溃恢复</strong></td><td>❌ 容易数据丢失，需要手动修复</td><td>✅ 崩溃后自动恢复</td></tr><tr><td><strong>存储方式</strong></td><td><strong>索引和数据分开存储</strong>，查询速度快</td><td><strong>索引和数据存储在一起</strong>，支持聚簇索引</td></tr><tr><td><strong>全文索引</strong></td><td>✅ 支持（MySQL 5.6 之前）</td><td>✅ MySQL 5.6+ 开始支持</td></tr><tr><td><strong>适用场景</strong></td><td><strong>查询多，写少</strong>（日志、数据分析）</td><td><strong>读写混合、高并发</strong>（金融、交易系统），数据安全要求高</td></tr></tbody></table><h3 id="_2、一个表中如果没有创建索引-那么还会创建b-树吗" tabindex="-1"><a class="header-anchor" href="#_2、一个表中如果没有创建索引-那么还会创建b-树吗" aria-hidden="true">#</a> 2、一个表中如果没有创建索引，那么还会创建B+树吗？</h3><p><strong>仍然会创建 B+ 树</strong>，因为 InnoDB <strong>默认使用</strong> <strong>主键作为聚簇索引</strong>，如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键，上面两个都没有的情况下，InnoDB 也会自动创建一个隐藏的 <strong>row_id</strong> 作为主键，并建立 B+ 树索引。</p><h3 id="_3、mysql-innodb引擎中的聚簇索引和非聚簇索引有什么区别" tabindex="-1"><a class="header-anchor" href="#_3、mysql-innodb引擎中的聚簇索引和非聚簇索引有什么区别" aria-hidden="true">#</a> 3、MySQL InnoDB引擎中的聚簇索引和非聚簇索引有什么区别？</h3><p>①、聚簇索引：聚簇索引的叶子节点保存了一行记录的所有列信息。也就是说，聚簇索引的叶子节点中，包含了一个完整的记录行。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503262133190.png" alt="聚簇索引" tabindex="0" loading="lazy"><figcaption>聚簇索引</figcaption></figure><p>②、非聚簇索引：它的叶子节点只包含一个主键值，通过非聚簇索引查找记录要先找到主键，然后通过主键再到聚簇索引中找到对应的记录行，这个过程被称为回表。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503262133219.png" alt="聚簇索引，以 age 为索引" tabindex="0" loading="lazy"><figcaption>聚簇索引，以 age 为索引</figcaption></figure><p>InnoDB 存储引擎的主键使用的是聚簇索引，MyISAM 存储引擎不管是主键索引，还是二级索引使用的都是非聚簇索引。</p><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引)，它也是利用了B+树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><ul><li>非聚簇索引可以优化 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作</li><li>覆盖索引（Covering Index）：避免回表，提高查询速度</li><li>适用于<strong>非主键列的查询</strong>， <strong>表有多个查询场景</strong>（如经常按 <code>Name</code>、<code>Score</code>、<code>Age</code> 过滤数据）</li></ul><blockquote><h3 id="_1-举个实际的例子" tabindex="-1"><a class="header-anchor" href="#_1-举个实际的例子" aria-hidden="true">#</a> <strong>1. 举个实际的例子</strong></h3><h4 id="_1-创建一个-student-表" tabindex="-1"><a class="header-anchor" href="#_1-创建一个-student-表" aria-hidden="true">#</a> <strong>① 创建一个 <code>Student</code> 表</strong></h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE Student (
    StudentID INT PRIMARY KEY,  -- 聚簇索引
    Name VARCHAR(50),
    Age INT,
    Score INT
);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>默认情况下，<code>StudentID</code> 作为 <code>PRIMARY KEY</code>，它就是聚簇索引。</strong></p><h4 id="_2-创建非聚簇索引" tabindex="-1"><a class="header-anchor" href="#_2-创建非聚簇索引" aria-hidden="true">#</a> <strong>② 创建非聚簇索引</strong></h4><p>我们希望加速按 <code>Score</code> 查询学生信息，因此创建一个 <strong>非聚簇索引</strong>：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">NONCLUSTERED</span> <span class="token keyword">INDEX</span> idx_Student_Score <span class="token keyword">ON</span> Student<span class="token punctuation">(</span>Score<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr><h3 id="_2-回表查询的情况" tabindex="-1"><a class="header-anchor" href="#_2-回表查询的情况" aria-hidden="true">#</a> <strong>2. 回表查询的情况</strong></h3><p>假设我们执行以下查询：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Name<span class="token punctuation">,</span> Age <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Score <span class="token operator">&gt;</span> <span class="token number">80</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>查询过程：</strong></p><ol><li><strong>先在 <code>idx_Student_Score</code> 非聚簇索引中查找</strong> <code>Score &gt; 80</code> 的记录，得到 <code>StudentID</code>（或指向数据行的 Row Locator）。</li><li><strong>再回到 <code>Student</code> 表</strong>（聚簇索引）中，通过 <code>StudentID</code> 找到 <code>Name</code> 和 <code>Age</code>。</li></ol><p><strong>问题：</strong></p><ul><li><code>idx_Student_Score</code> <strong>只存储了 <code>Score</code>，但查询需要 <code>Name</code> 和 <code>Age</code>，所以必须回表查询完整数据</strong>。</li><li><strong>回表操作增加了 I/O 和查询时间，影响性能</strong>。</li></ul><hr><h3 id="_3-使用覆盖索引优化查询" tabindex="-1"><a class="header-anchor" href="#_3-使用覆盖索引优化查询" aria-hidden="true">#</a> <strong>3. 使用覆盖索引优化查询</strong></h3><h4 id="_1-创建覆盖索引" tabindex="-1"><a class="header-anchor" href="#_1-创建覆盖索引" aria-hidden="true">#</a> <strong>① 创建覆盖索引</strong></h4><p>为了避免回表，我们可以创建一个<strong>包含 <code>Name</code> 和 <code>Age</code> 的非聚簇索引</strong>：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">NONCLUSTERED</span> <span class="token keyword">INDEX</span> idx_Student_Score <span class="token keyword">ON</span> Student<span class="token punctuation">(</span>Score<span class="token punctuation">)</span> INCLUDE<span class="token punctuation">(</span>Name<span class="token punctuation">,</span> Age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>覆盖索引的作用：</strong></p><ul><li><strong>索引不仅包含 <code>Score</code>，还包含 <code>Name</code> 和 <code>Age</code></strong>，因此查询时可以直接从索引中获取数据，不需要回表。</li></ul><hr><h3 id="_4-使用覆盖索引后的查询" tabindex="-1"><a class="header-anchor" href="#_4-使用覆盖索引后的查询" aria-hidden="true">#</a> <strong>4. 使用覆盖索引后的查询</strong></h3><p>再次执行：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Name<span class="token punctuation">,</span> Age <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Score <span class="token operator">&gt;</span> <span class="token number">80</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>查询过程（优化后）：</strong></p><ol><li><strong>直接在 <code>idx_Student_Score</code> 索引中查找</strong> <code>Score &gt; 80</code> 的记录。</li><li><strong>索引已经包含 <code>Name</code> 和 <code>Age</code></strong>，所以数据库<strong>不需要回表</strong>，直接从索引中返回结果。</li></ol></blockquote><h3 id="_4、有哪些索引类型" tabindex="-1"><a class="header-anchor" href="#_4、有哪些索引类型" aria-hidden="true">#</a> 4、有哪些索引类型？</h3><ul><li>B+树索引：所有数据存储在叶子节点，复杂度为<code>O(logn)</code>，适合范围查询。</li><li>哈希索引: 适合等值查询，检索效率高，一次到位。</li><li>全文索引：<code>MyISAM</code>和<code>InnoDB</code>中都支持使用全文索引，一般在文本类型<code>char,text,varchar</code>类型上创建。</li><li><code>R-Tree</code>索引: 用来对<code>GIS</code>数据类型创建<code>SPATIAL</code>索引</li></ul><h3 id="_5、b树和b-树的区别" tabindex="-1"><a class="header-anchor" href="#_5、b树和b-树的区别" aria-hidden="true">#</a> 5、B树和B+树的区别？</h3><ul><li>数据存储位置</li><li>B树搜索路径可能更短就能查到目标数据</li><li>B+树支持范围查询</li><li>树的高度更低，意味着磁盘 I/O <strong>更少</strong></li><li><strong>B+树</strong>插入或删除<strong>只影响叶子节点</strong>，内部索引节点不存数据，调整较简单；<strong>B树</strong>插入或删除可能影响<strong>所有节点</strong>，调整较复杂。</li></ul><p>所以<strong>B树</strong>适用于纯内存操作的情况，比如说MongoDB，而<strong>B+树</strong>适用于<strong>数据库和文件系统</strong>，对磁盘 I/O 友好，范围查询高效（如 MySQL 索引结构）。</p><h3 id="_6、为什么不用二叉树-或者平衡二叉树" tabindex="-1"><a class="header-anchor" href="#_6、为什么不用二叉树-或者平衡二叉树" aria-hidden="true">#</a> 6、为什么不用二叉树？或者平衡二叉树？</h3><p>二叉树坏的情况下可能退化成链表，失去了BST的优势（不能像二分查找那样减少搜索范围）。</p><p>平衡二叉树虽然可以避免 BST 退化成链表，保持平衡；但是也是二叉的结构，一个结点存储一个值，树依然很高，不利于IO操作。</p><h3 id="_7、一次b-树索引树查找过程" tabindex="-1"><a class="header-anchor" href="#_7、一次b-树索引树查找过程" aria-hidden="true">#</a> 7、一次B+树索引树查找过程</h3><blockquote><p>假设有以下表结构，并且初始化了这几条数据‘</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>employee<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>name<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>age<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>date<span class="token punctuation">\`</span></span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>sex<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>idx_age<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>age<span class="token punctuation">\`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>

<span class="token keyword">insert</span> <span class="token keyword">into</span> employee <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">&#39;小伦&#39;</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token string">&#39;2021-01-20&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;0&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> employee <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">&#39;俊杰&#39;</span><span class="token punctuation">,</span><span class="token number">48</span><span class="token punctuation">,</span><span class="token string">&#39;2021-01-21&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;0&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> employee <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token string">&#39;紫琪&#39;</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token string">&#39;2020-01-21&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> employee <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">&#39;立红&#39;</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token string">&#39;2020-01-21&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;0&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> employee <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token string">&#39;易迅&#39;</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token string">&#39;2020-01-21&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> employee <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">,</span><span class="token string">&#39;小军&#39;</span><span class="token punctuation">,</span><span class="token number">49</span><span class="token punctuation">,</span><span class="token string">&#39;2021-01-21&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;0&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> employee <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">700</span><span class="token punctuation">,</span><span class="token string">&#39;小燕&#39;</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token string">&#39;2021-01-21&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行这条查询SQL，需要执行几次的树搜索操作？可以画下对应的索引树结构图~</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> Temployee <span class="token keyword">where</span> age<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>idx_age</code>普通索引的索引结构图：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/weixin-mysqlsylwkz-baca02c4-1ed6-421f-9ad4-e3e63dd58efa.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>id</code>主键索引，聚族索引结构图：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/weixin-mysqlsylwkz-8bf752f5-772b-4308-b51c-d06406428866.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这条 SQL 查询语句执行大概流程是这样的：</p><ul><li>搜索<code>idx_age</code> 索引树，将<code>磁盘块1</code>加载到内存，由于<code>32&lt;43</code>,搜索左路分支，到磁盘寻址<code>磁盘块2</code>。</li><li>将<code>磁盘块2</code>加载到内存中，由于<code>32&lt;36</code>,搜索左路分支，到磁盘寻址<code>磁盘块4</code>。</li><li>将<code>磁盘块4</code>加载到内存中，在内存继续遍历，找到<code>age=32</code>的记录，取得<code>id = 400</code>.</li><li>拿到<code>id=400</code>后，回到<code>id主键索引树</code>。</li><li>搜索<code>id主键索引树</code>，将<code>磁盘块1</code>加载到内存，因为<code>300&lt;400&lt;500</code>,所以在选择中间分支，到磁盘寻址<code>磁盘块3</code>。</li><li>虽然在<code>磁盘块3</code>，找到了id=400，但是它不是叶子节点，所以会继续往下找。到磁盘寻址<code>磁盘块8</code>。</li><li>将<code>磁盘块8</code>加载内存，在内存遍历，找到<code>id=400</code>的记录，拿到<code>R4</code>这一行的数据，好的，大功告成。</li></ul><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250204114048506.png" alt="image-20250204114048506" style="zoom:50%;"><p>这个图也挺好。</p><h3 id="_8、什么是回表-如何减少回表" tabindex="-1"><a class="header-anchor" href="#_8、什么是回表-如何减少回表" aria-hidden="true">#</a> 8、什么是回表？如何减少回表？</h3><p>当查询的数据在索引树中，找不到的时候，需要回到<strong>主键索引树</strong>中去获取，这个过程叫做<strong>回表</strong>。</p><p>就像上面的SQL</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> Temployee <span class="token keyword">where</span> age<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>需要查询所有列的数据，<code>idx_age</code>普通索引不能满足，需要拿到主键id的值后，再回到<code>id</code>主键索引查找获取，这个过程就是回表。</p><h3 id="_8、什么是覆盖索引" tabindex="-1"><a class="header-anchor" href="#_8、什么是覆盖索引" aria-hidden="true">#</a> 8、什么是覆盖索引？</h3><p>如果查询SQL的<code>select *</code> 修改为 <code>select id, age</code>的话，其实是<strong>不需要回表</strong>的。因为<code>id</code>和<code>age</code>的值，都在<code>idx_age</code>索引树的叶子节点上。</p><blockquote><p>覆盖索引是<code>select</code>的数据列只用从索引中就能够取得，不必回表，换句话说，查询列要被所建的索引覆盖。</p></blockquote><h3 id="_9、聊聊索引的最左前缀原则" tabindex="-1"><a class="header-anchor" href="#_9、聊聊索引的最左前缀原则" aria-hidden="true">#</a> 9、聊聊索引的最左前缀原则</h3><p>在联合索引，也就是在多个列上创建的索引 的基础上遵循在查找时会优先使用下面的第一个<code>a</code>作为匹配依据的规则。</p><p>比如你建立一个组合索引<code>（a,b,c）</code>，其实可以相当于建了<code>（a），（a,b）,(a,b,c)</code>三个索引，大大提高了索引复用能力。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM users WHERE name = &#39;Alice&#39;;  -- ✅ 可以用索引，因为 name 是最左列
SELECT * FROM users WHERE name = &#39;Alice&#39; AND age = 25;  -- ✅ 可以用索引
SELECT * FROM users ORDER BY name, age;  -- ✅ 排序字段索引
SELECT * FROM users WHERE age = 25;  -- ❌ 不能用 idx_name_age，因为 age 不是最左列
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个SQL: <code>select * from employee where name like &#39;小%&#39; order by age desc;</code> 也是命中索引的。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/weixin-mysqlsylwkz-3c751d80-02df-43cf-acc7-aafdb409811b.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_10、什么是索引下推" tabindex="-1"><a class="header-anchor" href="#_10、什么是索引下推" aria-hidden="true">#</a> 10、什么是索引下推</h3><p>给你这个SQL：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employee <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">&#39;小%&#39;</span> <span class="token operator">and</span> age<span class="token operator">=</span><span class="token number">28</span> <span class="token operator">and</span> sex<span class="token operator">=</span><span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中，<code>name</code>和<code>age</code>为联合索引（<code>idx_name_age</code>）。</p><p>如果是<strong>Mysql5.6之前</strong>，在<code>idx_name_age</code>索引树，找出所有名字第一个字是<code>“小”</code>的人，拿到它们的<code>主键id</code>，然后回表找出数据行，再去对比年龄和性别等其他字段。如图：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/weixin-mysqlsylwkz-b5ccdd0e-f299-49ac-9176-8e2c475f606f.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>有些可能会觉得奇怪，<code>idx_name_age（name,age)</code>不是联合索引嘛？为什么选出包含<code>“小”</code>字后，不再顺便看下年龄<code>age</code>再回表呢，不是更高效嘛？所以呀，<code>MySQL 5.6</code>就引入了<strong>索引下推优化</strong>，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><p>因此，MySQL5.6版本之后，选出包含<code>“小”</code>字后，顺表过滤<code>age=28</code></p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/weixin-mysqlsylwkz-4b37d45c-b5a2-4ff7-8125-ccd1e89eed42.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_11、hash-索引和-b-树区别是什么" tabindex="-1"><a class="header-anchor" href="#_11、hash-索引和-b-树区别是什么" aria-hidden="true">#</a> 11、Hash 索引和 B+树区别是什么？</h3><ul><li>B+树可以进行范围查询，Hash 索引不能。</li><li>B+树支持 order by 排序，Hash 索引不支持。</li><li>Hash 索引在等值查询上比 B+树效率更高。（但是索引列的重复值很多的话，Hash冲突，效率降低）。</li><li>B+树使用 like 进行模糊查询的时候，like 后面（比如%开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。</li></ul><h3 id="_12、哪些操作会导致索引失效" tabindex="-1"><a class="header-anchor" href="#_12、哪些操作会导致索引失效" aria-hidden="true">#</a> 12、哪些操作会导致索引失效？</h3><p>索引失效是指查询优化器没有使用已创建的索引，而是选择了<mark>全表扫描</mark>（<code>FULL TABLE SCAN</code>）或其他低效的查询方式。</p><ul><li><p>like错误使用，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。相当于全表扫描</p></li><li><p>索引中使用了运算 例如这个SQL <code>select*from user where id+3=8</code>。这样会导致全表扫描计算id的值再进行比较，使得索引失效。</p></li><li><p>索引上使用了函数也会失效 例如：<code>select*from user where LOWER(name) like&#39;cong%&#39;</code>;。这样也会导致索引失效，索引参与了函数处理，会导致去全表扫描。</p></li><li><p>使用了联合索引却不符合最左前缀</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> age <span class="token operator">=</span> <span class="token number">25</span> <span class="token operator">AND</span> name <span class="token operator">=</span> <span class="token string">&#39;Alice&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Alice&#39;</span><span class="token punctuation">;</span> <span class="token comment">//失效</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>隐式类型转换</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token number">1300000001</span><span class="token punctuation">;</span> <span class="token comment">//失效，phone 字符串转化成数字 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">;</span> <span class="token comment">//生效，&quot;1&quot;自动转换成数字1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>WHERE 子句中的 OR</p></li></ul><p>在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,67),p=[t];function c(d,l){return s(),a("div",null,p)}const r=n(o,[["render",c],["__file","3.mysql index.html.vue"]]);export{r as default};
