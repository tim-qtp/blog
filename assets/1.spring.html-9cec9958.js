import{_ as a,W as n,X as s,a2 as e}from"./framework-48328e23.js";const i={},t=e(`<h3 id="什么是循环依赖问" tabindex="-1"><a class="header-anchor" href="#什么是循环依赖问" aria-hidden="true">#</a> 什么是循环依赖问？</h3><p>A 依赖 B，B 依赖 A，或者 C 依赖 C，就成了循环依赖。</p><p>看下方的代码就知晓了</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//或者自己依赖自己</span>
<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503071359292.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>原因很简单，AB 循环依赖，A 实例化的时候，发现依赖 B，创建 B 实例，创建 B 的时候发现需要 A，创建 A1 实例……无限套娃。。。。</p><h3 id="怎么解决循环依赖呢" tabindex="-1"><a class="header-anchor" href="#怎么解决循环依赖呢" aria-hidden="true">#</a> 怎么解决循环依赖呢？</h3><p>Spring 通过三级缓存机制来解决循环依赖：</p><ol><li>一级缓存：存放完全初始化好的单例 Bean。</li><li>二级缓存：存放正在创建但未完全初始化的 Bean 实例。</li><li>三级缓存：存放 Bean 工厂对象，用于提前暴露 Bean。</li></ol><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503071424654.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>A 实例的初始化过程：</strong></p><p>①、创建 A 实例，实例化的时候把 A 的对象⼯⼚放⼊三级缓存，表示 A 开始实例化了，虽然这个对象还不完整，但是先曝光出来让大家知道。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503071426843.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>②、A 注⼊属性时，发现依赖 B，此时 B 还没有被创建出来，所以去实例化 B。</p><p>③、同样，B 注⼊属性时发现依赖 A，它就从缓存里找 A 对象。依次从⼀级到三级缓存查询 A。</p><p>发现可以从三级缓存中通过对象⼯⼚拿到 A，虽然 A 不太完善，<mark>但是存在</mark>，就把 A 放⼊⼆级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成了，把 B 放入⼀级缓存。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503071438799.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>④、接着 A 继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除⼆级缓存中的 A，同时把 A 放⼊⼀级缓存</p><p>⑤、最后，⼀级缓存中保存着实例化、初始化都完成的 A、B 对象。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503071440758.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="为什么要三级缓存-二级不行吗" tabindex="-1"><a class="header-anchor" href="#为什么要三级缓存-二级不行吗" aria-hidden="true">#</a> 为什么要三级缓存？⼆级不⾏吗？</h3><p>不行，主要是为了 <strong>⽣成<mark>代理对象</mark></strong>。如果是没有代理的情况下，使用二级缓存解决循环依赖也是 OK 的。但是如果存在代理，三级没有问题，二级就不行了。</p><p>涉及到<strong>动态代理（AOP）</strong> 时，直接使用二级缓存不做任何处理会导致我们<strong>拿到的 Bean 是未代理的原始对象</strong>。</p><blockquote><p>因为当 Spring 创建一个 Bean（比如 ABean）时，如果这个 Bean 需要 AOP 代理（例如通过 <code>@Transactional</code> 或其他切面），Spring 并不会直接将原始实例暴露出去。相反，它会把一个生成该 Bean 的<mark>代理对象的工厂</mark>（<mark>ObjectFactory</mark>）存放到三级缓存中。</p><p>如果其他 Bean 在初始化过程中依赖 ABean，Spring 会依次从一级缓存、二级缓存查找。如果都找不到，就会去三级缓存取出 ObjectFactory，并调用它的 <code>getEarlyBeanReference()</code> 方法。这个方法会<mark>检查当前 Bean</mark>是否需要代理，<mark>并返回一个代理后的早期引用</mark>。随后，这个早期引用会放入二级缓存供后续使用。</p></blockquote><p>如果没有第二级缓存就会出现<mark>早期实例引用</mark>和<mark>被代理后的早期实例引用</mark>相互覆盖！</p>`,25),p=[t];function c(o,l){return n(),s("div",null,p)}const d=a(i,[["render",c],["__file","1.spring.html.vue"]]);export{d as default};
