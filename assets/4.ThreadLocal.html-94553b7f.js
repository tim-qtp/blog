import{_ as a,W as n,X as s,a2 as e}from"./framework-6a3aa88c.js";const c={},t=e(`<h3 id="🌟threadlocal-是什么" tabindex="-1"><a class="header-anchor" href="#🌟threadlocal-是什么" aria-hidden="true">#</a> 🌟ThreadLocal 是什么？</h3><p>ThreadLocal 是一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503112042604.png" alt="ThreadLocal线程副本" tabindex="0" loading="lazy"><figcaption>ThreadLocal线程副本</figcaption></figure><p>使用 ThreadLocal 通常分为四步：</p><p>①、创建 ThreadLocal</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//创建一个ThreadLocal变量</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> localVariable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>②、设置 ThreadLocal 的值</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//设置ThreadLocal变量的值</span>
localVariable<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王二是沙雕&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>③、获取 ThreadLocal 的值</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//获取ThreadLocal变量的值</span>
<span class="token class-name">String</span> value <span class="token operator">=</span> localVariable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>④、删除 ThreadLocal 的值</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//删除ThreadLocal变量的值</span>
localVariable<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Web 应用中，可以使用 ThreadLocal 存储用户会话信息，这样每个线程在处理用户请求时都能方便地访问当前用户的会话信息。</p><p>在数据库操作中，可以使用 ThreadLocal 存储数据库连接对象，每个线程有自己独立的数据库连接，从而避免了多线程竞争同一数据库连接的问题。</p><p>在格式化操作中，例如日期格式化，可以使用 ThreadLocal 存储 SimpleDateFormat 实例，避免多线程共享同一实例导致的线程安全问题。</p><h3 id="threadlocal-有哪些优点" tabindex="-1"><a class="header-anchor" href="#threadlocal-有哪些优点" aria-hidden="true">#</a> ThreadLocal 有哪些优点？</h3><p>每个线程访问的变量副本都是独立的，避免了共享变量引起的线程安全问题。由于 ThreadLocal 实现了变量的线程独占，使得变量不需要同步处理，因此能够避免资源竞争。</p><p>ThreadLocal 可用于跨方法、跨类时传递上下文数据，不需要在方法间传递参数。</p><h3 id="实际项目中用到的-threadlocal" tabindex="-1"><a class="header-anchor" href="#实际项目中用到的-threadlocal" aria-hidden="true">#</a> 实际项目中用到的 ThreadLocal ？</h3><p>用来存储用户信息，登录后的用户每次访问接口，都会在请求头中携带一个 token，在控制层可以根据这个 token，解析出用户的基本信息。</p><p>假如在服务层和持久层也要用到用户信息，就可以在控制层拦截请求把用户信息存入 ThreadLocal。</p><p>这样我们在任何一个地方，都可以取出 ThreadLocal 中存的用户信息</p><p>很多其它场景的 cookie、session 等等数据隔离都可以通过 ThreadLocal 去实现。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503112047687.png" alt="ThreadLoca存放用户上下文" tabindex="0" loading="lazy"><figcaption>ThreadLoca存放用户上下文</figcaption></figure><h3 id="threadlocal-怎么实现的呢" tabindex="-1"><a class="header-anchor" href="#threadlocal-怎么实现的呢" aria-hidden="true">#</a> ThreadLocal 怎么实现的呢？</h3><p>当我们创建一个 ThreadLocal 对象并调用 set 方法时，其实是在当前线程中初始化了一个 ThreadLocalMap。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503112047996.png" alt="ThreadLocalMap" tabindex="0" loading="lazy"><figcaption>ThreadLocalMap</figcaption></figure><p>ThreadLocalMap 是 ThreadLocal 的一个静态内部类，它内部维护了一个 Entry 数组，key 是 ThreadLocal 对象，value 是线程的局部变量，这样就相当于为每个线程维护了一个变量副本。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503112048408.png" alt="ThreadLoca结构图" tabindex="0" loading="lazy"><figcaption>ThreadLoca结构图</figcaption></figure><p>Entry 继承了 WeakReference，它限定了 key 是一个弱引用，弱引用的好处是当内存不足时，JVM 会回收 ThreadLocal 对象，并且将其对应的 Entry.value 设置为 null，这样可以在很大程度上避免内存泄漏。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/** The value associated with this ThreadLocal. */</span>
    <span class="token class-name">Object</span> value<span class="token punctuation">;</span>

    <span class="token comment">//节点类</span>
    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//key赋值</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//value赋值</span>
        value <span class="token operator">=</span> v<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结一下：</p><p>ThreadLocal 的实现原理是，每个线程维护一个 Map，key 为 ThreadLocal 对象，value 为想要实现线程隔离的变量（对象）。</p><p>1、通过 ThreadLocal 的 set 方法将对象存入 Map 中。</p><p>2、通过 ThreadLocal 的 get 方法从 Map 中取出对象。</p><p>3、Map 的大小由 ThreadLocal 对象的多少决定。</p><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503112113995.png" style="zoom:50%;"><h3 id="什么是弱引用-什么是强引用" tabindex="-1"><a class="header-anchor" href="#什么是弱引用-什么是强引用" aria-hidden="true">#</a> 什么是弱引用，什么是强引用？</h3><p>先说一下强引用，比如 <code>User user = new User(&quot;秦一&quot;)</code> 中，user 就是一个强引用，<code>new User(&quot;秦一&quot;)</code> 就是强引用对象。</p><p>当 user 被置为 null 时（<code>user = null</code>），<code>new User(&quot;秦一&quot;)</code> 对象就会被垃圾回收；否则即便是内存空间不足，JVM 也不会回收 <code>new User(&quot;秦一&quot;)</code> 这个强引用对象，宁愿抛出 OutOfMemoryError。</p><p>弱引用，比如说在使用 ThreadLocal 中，Entry 的 key 就是一个弱引用对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> userThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
userThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王二&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>userThreadLocal 是一个强引用，<code>new ThreadLocal&lt;&gt;()</code> 是一个强引用对象；</p><p><code>new User(&quot;秦一&quot;)</code> 是一个强引用对象。</p><p>调用 set 方法后，会将 <code>key = new ThreadLocal&lt;&gt;()</code> 放入 ThreadLocalMap 中，此时的 key 是一个弱引用对象。当 JVM 进行垃圾回收时，如果发现了弱引用对象，就会将其回收。</p><h3 id="为什么使用弱引用" tabindex="-1"><a class="header-anchor" href="#为什么使用弱引用" aria-hidden="true">#</a> <strong>为什么使用弱引用？</strong></h3><p>在 <code>ThreadLocal</code> 中使用弱引用的原因是：</p><ul><li><strong>避免内存泄漏</strong>：如果 <code>ThreadLocal</code> 对象是强引用，那么线程结束时，<code>ThreadLocalMap</code> 中的条目可能不会被清理，导致内存泄漏。</li><li><strong>自动清理</strong>：使用弱引用可以让 JVM 在回收 <code>ThreadLocal</code> 对象时，自动清理对应的条目，减少内存泄漏的风险。</li></ul><h3 id="父线程能用-threadlocal-给子线程传值吗" tabindex="-1"><a class="header-anchor" href="#父线程能用-threadlocal-给子线程传值吗" aria-hidden="true">#</a> 父线程能用 ThreadLocal 给子线程传值吗？</h3><p>不能。</p><p>因为 ThreadLocal 变量存储在每个线程的 ThreadLocalMap 中，而子线程<mark>不会继承父线程的 ThreadLocalMap</mark>。</p><p>可以使用 <code>InheritableThreadLocal</code>来解决这个问题。</p><p>子线程在创建的时候会拷贝父线程的 InheritableThreadLocal 变量。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">InheritableThreadLocalExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">InheritableThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> inheritableThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InheritableThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inheritableThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;父线程的值&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;子线程获取的值：&quot;</span> <span class="token operator">+</span> inheritableThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 继承了父线程的值</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="inheritablethreadlocal的原理" tabindex="-1"><a class="header-anchor" href="#inheritablethreadlocal的原理" aria-hidden="true">#</a> InheritableThreadLocal的原理</h3><p>在 Thread 类的定义中，每个线程都有两个 ThreadLocalMap：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 普通 ThreadLocal 变量存储的地方 */</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">/* InheritableThreadLocal 变量存储的地方 */</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>普通 ThreadLocal 变量存储在 threadLocals 中，不会被子线程继承。</p><p>InheritableThreadLocal 变量存储在 inheritableThreadLocals 中，当 <code>new Thread()</code> 创建一个子线程时，Thread 的 <code>init()</code> 方法会检查父线程是否有 inheritableThreadLocals，如果有，就会拷贝 InheritableThreadLocal 变量到子线程：</p>`,59),p=[t];function o(l,i){return n(),s("div",null,p)}const r=a(c,[["render",o],["__file","4.ThreadLocal.html.vue"]]);export{r as default};
