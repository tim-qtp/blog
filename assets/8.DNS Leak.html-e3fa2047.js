import{_ as c,W as p,X as t,$ as s,a0 as o,Z as e,a2 as n,C as d}from"./framework-6a3aa88c.js";const l={},i={href:"https://ipleak.net/",target:"_blank",rel:"noopener noreferrer"},r=n(`<p>如果列表中有国内的DNS服务器，那肯定泄露了。即使没有国内的 <code>DNS</code>，如果同一个节点使用全局模式和分流模式的检测结果不同，出现了新的 <code>DNS</code> 提供商，也大概率泄露了。并且直接把 <code>DNS</code> 泄露检测的网站添加到分流规则中来绕过 <code>DNS</code> 泄露，是一种掩耳盗铃的做法。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201203339435.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>DNS</code> 的泄露会导致运营商或者防火墙知道你在访问 <code>Google</code>、<code>YouTube</code>、<code>Facebook</code> 等网站，说白了就是知道你在科学上网。另外，像 <code>Netflix</code> 这种对地区敏感的应用，会通过 <code>DNS</code> 来判断你的实际所在地。如果存在泄露，将会被判定为使用了代理工具，可能无法使用他们的服务。</p><p>这篇主要讲讲为什么 <code>DNS</code> 会泄露，以及移动端和 <code>PC</code> 如何解决 <code>DNS</code> 泄露，顺便能解决有时无法访问部分网站的情况。</p><p>但是开始之前还有一个名词叫DNS污染：</p><h4 id="dns-污染的原理" tabindex="-1"><a class="header-anchor" href="#dns-污染的原理" aria-hidden="true">#</a> DNS 污染的原理</h4><ol><li><strong>正常 DNS 查询流程</strong>： <ul><li>你的设备向 DNS 服务器发送查询请求（如 <code>facebook.com</code>）。</li><li>DNS 服务器返回正确的 IP 地址（如 <code>31.13.71.36</code>）。</li></ul></li><li><strong>DNS 污染的流程</strong>： <ul><li>攻击者或干扰者伪造 DNS 响应，返回一个错误的 IP 地址（如 <code>1.2.3.4</code>）。</li><li>你的设备接收到伪造的响应，并尝试连接错误的 IP 地址。</li><li>结果可能是无法访问目标网站，或者被重定向到钓鱼网站。</li></ul></li></ol><h4 id="dns-污染的实现方式" tabindex="-1"><a class="header-anchor" href="#dns-污染的实现方式" aria-hidden="true">#</a> DNS 污染的实现方式</h4><ol><li><strong>中间人攻击（MITM）</strong>： <ul><li>攻击者在你的设备和 DNS 服务器之间拦截并篡改 DNS 响应。</li></ul></li><li><strong>伪造 DNS 服务器</strong>： <ul><li>攻击者运行一个恶意 DNS 服务器，返回虚假的 IP 地址。</li></ul></li><li><strong>网络运营商或政府干扰</strong>： <ul><li>某些国家或地区通过 DNS 污染技术屏蔽特定网站（如 Google、Facebook）。</li></ul></li></ol><h4 id="如何防止-dns-污染" tabindex="-1"><a class="header-anchor" href="#如何防止-dns-污染" aria-hidden="true">#</a> 如何防止 DNS 污染？</h4><ol><li><strong>使用加密 DNS</strong>： <ul><li>启用 DNS-over-HTTPS（DoH）或 DNS-over-TLS（DoT），加密 DNS 查询，防止被篡改。</li><li>例如：在浏览器中启用 DoH（如 Firefox 的加密 DNS 功能）。</li></ul></li><li><strong>更换可靠的 DNS 服务器</strong>： <ul><li>使用受信任的公共 DNS 服务器，如： <ul><li>Google DNS：<code>8.8.8.8</code> 和 <code>8.8.4.4</code></li><li>Cloudflare DNS：<code>1.1.1.1</code> 和 <code>1.0.0.1</code></li></ul></li></ul></li><li><strong>使用 VPN</strong>： <ul><li>VPN 可以加密所有网络流量，包括 DNS 查询，防止 DNS 污染。</li></ul></li><li><strong>手动修改 hosts 文件</strong>： <ul><li>对于经常访问的网站，可以在本地 hosts 文件中直接绑定域名和正确的 IP 地址。</li></ul></li></ol><p>接下来讲解DNS泄露！</p><p>DNS泄露(DNS Leak)是指在使用虚拟专用网络(VPN)时，设备的DNS请求并没有通过VPN隧道加密发送，而是通过用户的默认DNS服务器（通常由本地互联网服务提供商提供)发送。这样就暴露了用户正在使用VPN访问的内容，使用VPN的意义就大打折扣，甚至可能有攻击者通过伪造DNS记录，窃取到本该通过VPN通道发送的内容，</p><p><code>DNS</code> 原本是一个非常简洁明了的协议，就是负责将域名解析成 <code>IP</code>。</p><p>但是为了实现分流，让这个原本简单的协议在代理中应用变得异常复杂。有些不正确的配置以为自己没漏，实际上早已露出了鸡脚。</p><p>要解释清楚 <code>DNS</code> 泄露是怎么产生的，就需要先来了解 <code>DNS</code> 的工作流程。先来创建一个最常见的家庭网络环境。你在运营商拉了一条宽带，它会给你分配一个光猫。一般来讲，你会单独再买一台路由器连着光猫，路由器通过 <code>PPPoE</code> 拨号，获取运营商分配的公网 <code>IP</code> 和 <code>DNS</code> 服务器。假设公网 <code>IP</code> 为 <code>2.2.2.2</code>，<code>DNS</code> 服务器一般会分配两个，假设其中一个的 <code>IP</code> 为 <code>3.3.3.3</code>。同时，路由器作为局域网的网关，会有自己的内网 <code>IP</code> 地址，假设为 <code>192.168.0.1</code>。家里的所有网络设备都会连接到这台路由器，路由器通过 <code>DHCP</code> 为每一台网络设备分配一个内网 <code>IP</code> 以及默认网关、<code>DNS</code> 等信息。一般情况下，默认网关和 <code>DNS</code> 服务器都是路由器。这是最常见的家庭网络拓扑。</p><p>首先，浏览器会检查浏览器 <code>DNS</code> 缓存里是否有百度的 <code>IP</code>，发现缓存列表中并没有。除去浏览器的 <code>DNS</code> 缓存，操作系统本身也有 <code>DNS</code> 的缓存列表，可以通过 <code>ipconfig /displaydns</code> 查询，其中包含我们在系统 <code>hosts</code> 文件中手动添加的绑定记录。</p><p>如果在操作系统 <code>DNS</code> 缓存中也没有找到，浏览器会构建一条 <code>DNS</code> 查询的应用层数据包，内容是百度的 <code>IP</code> 地址是多少。 <code>DNS</code> 服务的默认端口是 <code>53</code>，默认传输方式是 <code>UDP</code>，所以传输层会以 <code>UDP</code> 的方式进行封装，并且目标端口是 <code>53</code>。网络层会封装源 <code>IP</code> 和目标 <code>IP</code>，源 <code>IP</code> 是本机电脑的 <code>IP</code>，目标 <code>IP</code> 是本机电脑配置的 <code>DNS</code> 服务器，也就是路由器的 <code>IP</code> <code>192.168.0.1</code>。接着封装 <code>MAC</code> 地址，并从网口发出数据，会来到路由器。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201210543944.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>路由器一看目标 <code>IP</code> 是自己，于是会一层层地解封装，得到电脑的 <code>DNS</code> 请求。</p><p>路由器同样首先检查自己的 <code>DNS</code> 缓存列表中是否有百度的 <code>IP</code> 地址，发现并没有。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201210805217.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>于是会构建一条 <code>DNS</code> 查询的应用层数据包，内容同样是 <code>baidu.com</code> 的 <code>IP</code> 地址是多少，目标 <code>IP</code> 为路由器配置的上游 <code>DNS</code> 服务器 <code>3.3.3.3</code>，并将其发送到互联网。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201210903415.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>数据包会来到运营商给我们分配的 <code>DNS</code> 服务器 <code>3.3.3.3</code>，收到数据后，得知了路由器想要百度的 <code>IP</code>，同样先检查自己的缓存列表，没有的话，再询问其他上游 <code>DNS</code> 服务器。运营商的 <code>DNS</code> 一般会配置多个上游 <code>DNS</code> 服务器，具体发给哪一台，会根据自己的负载均衡策略选择。 <img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201211048617.png" alt="" loading="lazy"></p><p>假设发给了 <code>IP</code> 为 <code>6.6.6.6</code> 的服务器，并且假设这台服务器没有配置 <code>DNS</code> 转发，所以不会将请求转发给其他 <code>DNS</code> 服务器，而是负责帮我们查询百度的 <code>IP</code>。这里查询过程不详细描述。</p><p>我们只需要知道，最终这台 <code>DNS</code> 服务器会找到解析 <code>baidu.com</code> 这个域名的权威 <code>DNS</code> 服务器，并把这条请求交给他。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201211434690.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201211423206.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>记住红色部分是我们当前两台服务器通信的 <code>IP</code>。百度的权威服务器收到请求后，他这里会有 <code>baidu.com</code> 这个域名绑定的 <code>IP</code>，于是将 <code>IP</code> 和 <code>TTL</code> 返回给这台 <code>DNS</code> 服务器。</p><p><code>TTL</code> 在 <code>DNS</code> 中表示缓存时间，假设为十分钟。</p><p>这台 <code>DNS</code> 收到数据后会缓存下来，并将结果告诉了运营商的 <code>DNS</code>。运营商的 <code>DNS</code> 同样也会将结果缓存，并发回给我们的路由器。路由器也是同样的操作，缓存下来，并将结果发回给我们的电脑。</p><p>但是家用路由器的性能有限，可能为了节省内存，会将 <code>TTL</code> 值设置得相对较小，比如 <code>30</code> 秒。</p><p>当浏览器获取到 <code>IP</code> 之后，才正式地开始发起访问百度的请求。</p><p>如果 <code>TTL</code> 值到期了，则会将记录从缓存中移除，又得重新发起 <code>DNS</code> 请求，获取百度的 <code>IP</code> 了。</p><p>为什么需要 <code>DNS</code>，以及 <code>DNS</code> 的执行流程相信大家都清楚了。接下来就是我们今天的主题，为什么会存在 <code>DNS</code> 泄露。<code>DNS</code> 泄露的说法只有在我们使用代理之后才存在。</p><p>假设我们当前没有使用代理的情况下查询 <code>DNS</code> 泄露，列表中返回了国内的 <code>DNS</code> 服务器，这只能说明这些 <code>DNS</code> 服务器负责帮我们进行了 <code>DNS</code> 查询，并不代表 <code>DNS</code> 泄露了。如果此时我将电脑的本地 <code>DNS</code> 服务器改成 <code>1.1.1.1</code>，意思是让 <code>1.1.1.1</code> 负责 <code>DNS</code> 解析，列表中返回了美国的 <code>DNS</code> 服务器，这也不能说明 <code>DNS</code> 没有泄露。</p><p>只有当我们通过代理访问目标网站时，电脑给互联网发送了请求目标网站 <code>IP</code> 地址的明文 <code>DNS</code> 请求，这种情况就是 <code>DNS</code> 泄露。</p><p>要讲清楚这个问题，就必须先来了解这个网站是如何进行 <code>DNS</code> 检测的。按 <code>F12</code> 调出浏览器的开发者面板，来到网络面板，可以看到网站在不停地发送请求，并且每个请求访问的域名都不一样，目的是为了确保我们的 <code>DNS</code> 缓存以及所有上游 <code>DNS</code> 缓存中都没有这条记录。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201222901638.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201222933850.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201222947367.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>根据之前的讲解，当浏览器中没有找到缓存，会构建查询域名 <code>IP</code> 的 <code>DNS</code> 请求。</p><p>由于域名完全随机，上游 <code>DNS</code> 也不可能会有缓存，请求将被转发到运营商的 <code>DNS</code>。由于运营商配置了多个上游 <code>DNS</code> 服务器，可能会交给不同的上游。</p><p>假设交给了第二台，这台 <code>DNS</code> 负责去寻找这个域名的 <code>IP</code>，最终会找到这个域名的权威 <code>DNS</code> 服务器。</p><p>由于设置了泛解析，查询任何子域名都能获取到 <code>IP</code>。权威服务器在返回结果给你的时候，偷偷做了一个动作，记录下了 <code>DNS</code> 服务器的 <code>IP</code> 地址，并且告诉了查询 <code>DNS</code> 泄露的网站。</p><p>由于每个访问者使用网站进行查询时，域名是完全随机的，也就是说，每个人发起 <code>DNS</code> 查询的域名都不一样，所以网站根据这条查询记录就能知道是你在使用这个 <code>DNS</code> 服务器，再根据 <code>IP</code> 归属地得知这个服务器的地理位置。</p><p>由于网站在不停地发送新的域名进行探测，运营商的 <code>DNS</code> 可能会使用不同的上游 <code>DNS</code>，所以可以探测到多个不同的 <code>DNS</code> 服务器 <code>IP</code> 地址。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201223415857.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>另外，虽然 <code>1.1.1.1</code> 是任播 <code>DNS</code>，但我们国内使用的话会被反向优化到美国，用美国的 <code>DNS</code> 服务器，那么它的上游 <code>DNS</code> 也肯定是美国的 <code>IP</code>。</p><p>所以当我将本地的 <code>DNS</code> 改成 <code>1.1.1.1</code> 之后，<code>DNS</code> 泄露查询到的都是美国的 <code>DNS</code> 服务器。</p><p>所以 <code>DNS</code> 泄露的并不是你的电脑 <code>IP</code>，而是你上上上上上上游的 <code>DNS</code> 服务器 <code>IP</code>。</p><p>这里可能松了一口气，觉得并没有什么大不了。但那么再来看一下使用代理之后是一个什么情况。</p><p>首先，浏览器要访问谷歌，由于配置了系统代理，浏览器不再进行 <code>DNS</code> 查询，而是直接将访问网站的请求交给我们的代理客户端。</p><p>代理客户端拿到请求之后，此时会有两种情况：</p><ul><li><p>一种是不发起 <code>DNS</code> 请求就能判断它是走直连还是走代理，这种情况基本不存在 <code>DNS</code> 泄露；</p></li><li><p>另一种情况是发起 <code>DNS</code> 请求，获取到 <code>IP</code> 之后，再来根据 <code>IP</code> 判断是走直连还是走代理，这种情况大概率存在 <code>DNS</code> 泄露。即使你配的 <code>DNS</code> 是 <code>1.1.1.1</code> 或者 <code>8.8.8.8</code> 这种国外的 <code>DNS</code> 提供商，只要发起了 <code>DNS</code> 请求，那就泄露了，还会迷惑你，因为查不到国内 <code>DNS</code>，还以为没有泄露。</p></li></ul><p>假设 <code>Clash</code> 使用了 <code>IP</code> 规则进行分流，所以需要先得到谷歌的 <code>IP</code> 地址，于是会发起 <code>DNS</code> 请求，内容是谷歌的 <code>IP</code> 地址是多少。</p><p>当这条请求发给互联网的 <code>DNS</code> 服务器之后，问题就发生了。<code>DNS</code> 请求是完全明文的，除非你使用 <code>DoT</code> 或者 <code>DoH</code> 进行加密，或者有些客户端默认会将 <code>DNS</code> 请求通过节点加密进行远程 <code>DNS</code>，这两种情况都会增加延迟，不算是好的方案。</p><p>大部分用户都不会进行加密和远程 <code>DNS</code>，也就是说，运营商或者中间任何一台路由器都可以看到你的意图是访问谷歌。后面的情况也就不用我细说了。当你要完谷歌的 <code>IP</code> 之后，马上给其他服务器发送一堆加密数据，<strong>鬼都知道你在干啥</strong>，甚至可能根据这个行为来封禁节点服务器。</p><p>再假设 <code>Netflix</code> 这种对地区要求高的网站，偷偷地发送了一个 <code>DNS</code>请求，如果存在 <code>DNS</code> 泄露，负责跟 <code>Netflix</code> 的权威 <code>DNS</code> 服务器对话的这台 <code>DNS</code> 服务器的 <code>IP</code> 归属地就会和当前访问 <code>Netflix</code> 网站的代理 <code>IP</code> 不是同一个地区，那就判定你在使用 <code>VPN</code> 工具，禁止观看。</p><p>当然这是我的假设，实际上 <code>Netflix</code> 有没有这样做，我并不清楚，猜的。从技术角度来讲这是可以实现的，并且是一个非常强的代理特征。这就是 <code>DNS</code> 泄露以及 <code>DNS</code> 泄露所导致的问题。</p><p>问题已经提出来了，那要怎么解决呢？</p><p><code>DNS</code> 泄露的原因就是在代理的情况下，本地发送了 <code>DNS</code> 请求，那只要让本地不发送 <code>DNS</code> 请求，直接将数据加密后发给节点服务器，就能避免了。因为加密的数据中已经包含了域名，<strong>节点服务器会负责 <code>DNS</code> 并帮我们访问网站</strong>。</p><p>本地进行 <code>DNS</code> 请求获取 <code>IP</code> 的行为只是为了匹配分流规则，<strong>所以只要我们的分流规则配置合理</strong>，就可以避免发起 <code>DNS</code>，从而降低延迟，解决 <code>DNS</code> 泄露。</p><p><code>v2rayN</code> 的用户比较简单，直接使用客户端提供的绕过大陆路由方式，就能解决 <code>DNS</code> 泄露的问题。更进一步，可以进入路由设置，将域名策略改成 <code>AsIs</code>。如果你以前手动修改过绕过大陆的路由规则，可以双击进入修改，将配置恢复成官方规则即可。</p><p><code>Clash</code> 麻烦一点，因为分流规则都写在订阅文件中。</p><p>解决这个问题的话要通过订阅转换，可以使用你信得过的订阅转换地址。在订阅链接中填入你的订阅地址或者节点，远程配置随便选择一个，点击生成订阅，会自动复制到剪贴板。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">[</span>custom<span class="token punctuation">]</span>
<span class="token punctuation">;</span>解决<span class="token constant">DNS</span>泄露，无分流群组
ruleset<span class="token operator">=</span>🚀 节点选择<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token constant">DOMAIN</span><span class="token operator">-</span><span class="token constant">SUFFIX</span><span class="token punctuation">,</span>xn<span class="token operator">--</span>ngstr<span class="token operator">-</span>lra8j<span class="token punctuation">.</span>com
ruleset<span class="token operator">=</span>🚀 节点选择<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token constant">DOMAIN</span><span class="token operator">-</span><span class="token constant">SUFFIX</span><span class="token punctuation">,</span>services<span class="token punctuation">.</span>googleapis<span class="token punctuation">.</span>cn
ruleset<span class="token operator">=</span>🚀 节点选择<span class="token punctuation">,</span><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span>master<span class="token operator">/</span>Clash<span class="token operator">/</span>Ruleset<span class="token operator">/</span>GoogleCNProxyIP<span class="token punctuation">.</span>list
ruleset<span class="token operator">=</span><span class="token constant">DIRECT</span><span class="token punctuation">,</span><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span>master<span class="token operator">/</span>Clash<span class="token operator">/</span>LocalAreaNetwork<span class="token punctuation">.</span>list
ruleset<span class="token operator">=</span><span class="token constant">DIRECT</span><span class="token punctuation">,</span><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span>master<span class="token operator">/</span>Clash<span class="token operator">/</span>UnBan<span class="token punctuation">.</span>list
ruleset<span class="token operator">=</span><span class="token constant">DIRECT</span><span class="token punctuation">,</span><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span>master<span class="token operator">/</span>Clash<span class="token operator">/</span>ChinaDomain<span class="token punctuation">.</span>list
ruleset<span class="token operator">=</span><span class="token constant">DIRECT</span><span class="token punctuation">,</span><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span>master<span class="token operator">/</span>Clash<span class="token operator">/</span>ChinaMedia<span class="token punctuation">.</span>list
ruleset<span class="token operator">=</span><span class="token constant">REJECT</span><span class="token punctuation">,</span><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span>master<span class="token operator">/</span>Clash<span class="token operator">/</span>BanAD<span class="token punctuation">.</span>list
ruleset<span class="token operator">=</span><span class="token constant">REJECT</span><span class="token punctuation">,</span><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span>master<span class="token operator">/</span>Clash<span class="token operator">/</span>BanProgramAD<span class="token punctuation">.</span>list
ruleset<span class="token operator">=</span><span class="token constant">DIRECT</span><span class="token punctuation">,</span><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span>master<span class="token operator">/</span>Clash<span class="token operator">/</span>ChinaCompanyIp<span class="token punctuation">.</span>list
ruleset<span class="token operator">=</span><span class="token constant">DIRECT</span><span class="token punctuation">,</span><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span><span class="token constant">ACL4SSR</span><span class="token operator">/</span>master<span class="token operator">/</span>Clash<span class="token operator">/</span>ChinaIp<span class="token punctuation">.</span>list
ruleset<span class="token operator">=</span><span class="token constant">DIRECT</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token constant">GEOIP</span><span class="token punctuation">,</span><span class="token constant">CN</span><span class="token punctuation">,</span>no<span class="token operator">-</span>resolve
ruleset<span class="token operator">=</span>🚀 节点选择<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token constant">FINAL</span>

custom_proxy_group<span class="token operator">=</span>🚀 节点选择<span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">select</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span>♻️ 自动选择<span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">[]DIRECT</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">.</span><span class="token operator">*</span>
custom_proxy_group<span class="token operator">=</span>♻️ 自动选择<span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">url-test</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">http://www.gstatic.com/generate_204</span><span class="token template-punctuation string">\`</span></span><span class="token number">300</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token number">50</span>

enable_rule_generator<span class="token operator">=</span><span class="token boolean">true</span>
overwrite_original_rules<span class="token operator">=</span><span class="token boolean">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,68),u=s("code",null,"config",-1),k={href:"https://cf.buliang0.cf/clash-rules/nodnsleak.ini",target:"_blank",rel:"noopener noreferrer"},g=s("code",null,"Clash for Windows",-1),S=n(`<p>如果下载失败，可以尝试将远程配置网址进行 <code>URL</code> 编码，或者换一个订阅转换后端。这条就是防 <code>DNS</code> 泄露的订阅地址，使用 <code>Clash</code> 内核的客户端都可以使用这个配置文件。这样设置后，使用系统代理就不会出现 <code>DNS</code> 泄露了。</p><p>如果使用 <code>TUN</code> 模式，则还需要进一步设置。</p><p>内置 <code>DNS</code> 要使用 <code>fake-ip</code> 模式，不要使用 <code>Clash</code> 已经弃用的 <code>redir-host</code> 模式。默认就是 <code>fake-ip</code>，不要去改它。</p><p>还没有完，和系统代理不一样，由于 <code>TUN</code> 模式是操作网络层，对于 <code>DNS</code> 的处理会更复杂。即使规则已经走全局，也还是会发起 <code>DNS</code> 请求。正常情况下，<code>Clash</code> 的虚拟网卡会进行拦截，但由于 <code>Windows</code> 系统默认会将 <code>DNS</code> 请求发给所有网卡上配置的 <code>DNS</code> 服务器，微软美其名曰把它叫做智能 <code>DNS</code> 优化，实际上会造成 <code>DNS</code> 泄露，因为 <code>Clash</code> 拦截不了物理网卡的 <code>DNS</code> 请求。</p><p>解决这个问题需要进行简单的设置。在开始菜单中搜索组策略，找到禁用智能多宿主名称解析，双击打开，选择“已启用”，点击应用。这样就可以禁用多网卡的 <code>DNS</code>请求了。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201232754795.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果你的电脑是win家庭版，可以通过运行以下方式开启策略组：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>@echo off
<span class="token function">pushd</span> <span class="token string">&quot;%~dp0&quot;</span>
<span class="token function">dir</span> /b C:<span class="token punctuation">\\</span>Windows<span class="token punctuation">\\</span>servicing<span class="token punctuation">\\</span>Packages<span class="token punctuation">\\</span>Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum <span class="token operator">&gt;</span>List.txt
<span class="token function">dir</span> /b C:<span class="token punctuation">\\</span>Windows<span class="token punctuation">\\</span>servicing<span class="token punctuation">\\</span>Packages<span class="token punctuation">\\</span>Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum <span class="token operator">&gt;&gt;</span>List.txt
<span class="token keyword">for</span> /f %%i <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">&#39;findstr /i . List.txt 2^&gt;nul&#39;</span><span class="token punctuation">)</span> <span class="token keyword">do</span> dism /online /norestart /add-package:<span class="token string">&quot;C:\\Windows\\servicing\\Packages\\%%i&quot;</span>
pause
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后用管理员身份运行</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250201232346449.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,10),N=n("<li>安卓的 <code>v2rayNG</code> 是勾选“启动本地 <code>DNS</code>”，启用虚拟 <code>DNS</code>，其实就是 <code>fake-ip</code>。将域名策略改成 <code>AsIs</code>，预定义规则设置绕过局域网以及大陆地址。其他配置按安装时默认的选项即可。记得要断开 <code>VPN</code> 重连，规则才会生效。</li><li><code>Clash</code> 除了要使用刚才的那个远程配置文件进行订阅转换之外，还需要其他设置。进入覆写，将 <code>DNS</code> 策略改成“强制启用”，增强模式改成 <code>fake-ip</code>。点击 <code>nameserver</code>，添加 <code>DNS</code> 服务器，填国内的即可，比如 <code>114</code>。你可以添加多个，这样就算是配置好了。</li>",2),D=s("code",null,"iOS",-1),m=s("code",null,"DNS",-1),h={href:"https://cf.buliang0.cf/shadowrocket-rules/nodnsleak-pk.ini",target:"_blank",rel:"noopener noreferrer"},f=n("<p>这样操作之后就能解决大部分 <code>DNS</code> 泄露的问题了。你可以重新检测 <code>DNS</code> 泄露的情况，<strong>只要全局模式和分流模式都是同样的 <code>DNS</code> 提供商</strong>，则大概率没有泄露。</p><p>没泄漏的情况下，如果看到了多个国家的 <code>DNS</code> 服务器，是你节点配置的上游 <code>DNS</code> 问题。如果是自建的节点，可以修改节点服务器的上游 <code>DNS</code> 解决这个问题。不过也可能是这个网站的 <code>IP</code> 归属地数据库更新不及时导致的。</p><p>另外，由于本地基本不再发起 <code>DNS</code> 请求，速度也会有一定的提升，也能解决 <code>DNS</code> 污染导致有些网站无法访问的情况。至于这样做为什么能阻止 <code>DNS</code> 请求，有没有缺点，下节讲 <code>DNS</code> 分流再来细说。</p><p>最后再来说一下浏览器的 <code>WebRTC</code> 泄露，会绕过代理直接泄露本机的真实 <code>IP</code>。访问这个网址可以进行查询。如果存在泄露，安装这款浏览器插件，禁用浏览器的 <code>WebRTC</code> 功能，可以防止 <code>IP</code> 地址泄露。</p>",4);function b(P,v){const a=d("ExternalLinkIcon");return p(),t("div",null,[s("p",null,[o("开始之前先用 "),s("a",i,[o("https://ipleak.net/"),e(a)]),o(" 这个网站查看一下你的DNS请求是否有泄露。")]),r,s("p",null,[o("然后 将 "),u,o(" 远程配置文件的网址删除，把"),s("a",k,[o("https://cf.buliang0.cf/clash-rules/nodnsleak.ini"),e(a)]),o("复制过去，将其粘贴到 "),g,o(" 中进行订阅下载。")]),S,s("ol",null,[N,s("li",null,[o("最后是 "),D,o(" 小火箭。小火箭的默认配置可以避免 "),m,o(" 泄露，但是分流不是很完善。可以使用 "),s("a",h,[o("https://cf.buliang0.cf/shadowrocket-rules/nodnsleak-pk.ini"),e(a)]),o(" 这个配置文件。点击添加配置，将地址粘贴上去，点击下载，选中刚才的这个地址，点击使用配置。最后只需要将全局路由设置为配置模式即可。")])]),f])}const C=c(l,[["render",b],["__file","8.DNS Leak.html.vue"]]);export{C as default};
