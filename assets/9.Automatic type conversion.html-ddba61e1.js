import{_ as o,W as e,X as c,a2 as t}from"./framework-6a3aa88c.js";const s={},d=t("<p>当把一个范围较小的数值或变量赋给另外一个范围较大的变量时，会进行自动类型转换；反之，需要强制转换。</p><p>这就好像，小杯里的水倒进大杯没问题，但大杯的水倒进小杯就可能会溢出。</p><p>①、<code>float f=3.4</code>，对吗？</p><p>不正确。3.4 默认是双精度，将双精度赋值给浮点型属于下转型（down-casting，也称窄化）会造成精度丢失，因此需要强制类型转换<code>float f =(float)3.4;</code>或者写成<code>float f =3.4F</code></p><p>②、<code>short s1 = 1; s1 = s1 + 1；</code>对吗？<code>short s1 = 1; s1 += 1;</code>对吗？</p><p><code>short s1 = 1; s1 = s1 + 1;</code> 会编译出错，由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。</p><p>而 <code>short s1 = 1; s1 += 1;</code>可以正确编译，因为 <code>s1+= 1;</code>相当于 <code>s1 = (short(s1 + 1);</code> 其中有隐含的强制类型转换。</p>",7),n=[d];function p(r,_){return e(),c("div",null,n)}const i=o(s,[["render",p],["__file","9.Automatic type conversion.html.vue"]]);export{i as default};
