import{_ as e,W as i,X as a,a2 as s}from"./framework-6a3aa88c.js";const d={},t=s(`<h3 id="什么是redis" tabindex="-1"><a class="header-anchor" href="#什么是redis" aria-hidden="true">#</a> 什么是Redis？</h3><p>Rdis是一种基于内存的NoSQL 数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。基于键值对（key-value）进行存储。</p><p>Redis提供了多种数据类型来支持不同的业务场景，比如String(字符串)、Hash(哈希)、List(列表)、Set(集 合)、Zset(有序集合)、Bitmaps(位图)、HyperLogLog(基数统计)、GEO(地理信息)、Stream(流)， 并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p><p>除此之外，Redis还支持事务、持久化、Lua脚本、多种集群方案（主从复制模式、哨兵模式、切片机群 模式)、发布/订阅模式，内存淘汰机制、过期删除机制等等。</p><h3 id="redis-常见的数据类型" tabindex="-1"><a class="header-anchor" href="#redis-常见的数据类型" aria-hidden="true">#</a> Redis 常见的数据类型？</h3><h4 id="_1、string" tabindex="-1"><a class="header-anchor" href="#_1、string" aria-hidden="true">#</a> ①、String</h4><ul><li>字符串（简单的字符串、复杂的字符串（例如 JSON、XML））</li><li>数字 （整数、浮点数）</li><li>甚至是二进制（图片、音频、视频），但最大不能超过 512MB</li></ul><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/string.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_2、hash" tabindex="-1"><a class="header-anchor" href="#_2、hash" aria-hidden="true">#</a> ②、Hash</h4><p>键值对集合，key 是字符串，value 是一个 Map 集合，比如说 <code>value = {name: &#39;秦一&#39;, age: 30}</code>，name 和 age 属于字段 field，秦一 和 30 属于值 value。</p><p>哈希主要有以下两个典型应用场景：</p><ul><li>缓存用户信息</li><li>缓存对象</li></ul><h4 id="什么使用-hash-类型而不使用-string-类型序列化存储" tabindex="-1"><a class="header-anchor" href="#什么使用-hash-类型而不使用-string-类型序列化存储" aria-hidden="true">#</a> 什么使用 hash 类型而不使用 string 类型序列化存储？</h4><p>感受一下：</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/image-20250206230329314.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看得出，使用 hash 比使用 string 更便于进行序列化，我们可以将一整个用户对象序列化，然后作为一个 value 存储在 Redis 中，存取更加便捷。</p><h4 id="_3、list" tabindex="-1"><a class="header-anchor" href="#_3、list" aria-hidden="true">#</a> ③、List</h4><p>顺序插入列表</p><p>主要有以下两个使用场景：</p><ul><li>消息队列</li><li>博客、新闻、论坛的最新文章流，保证<strong>最新文章在最前面</strong></li></ul><h4 id="_4、-bitmap" tabindex="-1"><a class="header-anchor" href="#_4、-bitmap" aria-hidden="true">#</a> ④、 BitMap</h4><p>Bitmap,即位图，是一串连续的二进制数组(0和1)，可以通过偏移量(offset).定位元素。BitMapi通过 最小的单位bt来进行1的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p><p>由于bit是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用二值统 计的场景。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/bitmap.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>比如说：</p><p><strong>签到统计</strong></p><p>在签到打卡的场景中，我们只用记录签到(1)或未签到(0)，所以它就是非常典型的二值状态。</p><p>签到统计时，每个用户一天的签到用1个bt位就能表示，一个月（假设是31天）的签到情况用31个 bt位就可以，而一年的签到也只需要用365个bt位，根本不用太复杂的集合类型。</p><p>假设我们要统计D100的用户在2022年6月份的签到情况，就可以按照下面的步骤进行操作。</p><p>第一步，执行下面的命令，记录该用户6月3号已签到。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>SETBIT uid:sign:<span class="token number">100</span>:<span class="token number">202206</span> <span class="token number">2</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第二步，检查该用户 6 月 3 日是否签到。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>GETBIT uid:sign:<span class="token number">100</span>:<span class="token number">202206</span> <span class="token number">2</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第三步，统计该用户在 6 月份的签到次数。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>BITCOUNT uid:sign:<span class="token number">100</span>:<span class="token number">202206</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，我们就知道该用户在 6 月份的签到情况了。</p><p>如何统计这个月首次打卡时间呢？</p><p>Redis提供了BITPOS key bitValue[start][end]指令，返回数据表示Bitmap中第一个值为bitValue 的offset位置。</p><p>在默认情况下，命令将检测整个位图，用户可以通过可选的start参数和end参数指定要检测的范 围。所以我们可以通过执行这条命令来获取usrD=100在2022年6月份首次打卡日期：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>BITPOS uid:sign:<span class="token number">100</span>:<span class="token number">202206</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>需要注意的是，因为 offset 从 0 开始的，所以我们需要将返回的 value + 1 。</p><p>⑤、Stream</p><p>redis的消息队列，之前做过一个项目，其中消息就是用的Stream，没有用RocketMQ。</p><h3 id="什么是-i-o-多路复用" tabindex="-1"><a class="header-anchor" href="#什么是-i-o-多路复用" aria-hidden="true">#</a> 什么是 I/O 多路复用？</h3><p>IO 多路复用是指在单线程中同时监控多个文件描述符（fd），一旦某个文件描述符就绪，就立即处理对应的事件。能够在没有阻塞的情况下高效地处理大量并发连接，实现高并发的 IO 操作。</p><p>常见的 I/O 多路复用机制包括 select、poll 和 epoll 等。</p><p>比如说你是一名数学老师，上课时提出了一个问题：“今天谁来证明一下勾股定律？”</p><p>同学小王举手，你就让小王回答；小李举手，你就让小李回答；小张举手，你就让小张回答。</p><p>这种模式就是 IO 多路复用，你只需要在讲台上等，谁举手谁回答，不需要一个一个去问。</p><p>Redis 就是使用 epoll 这样的 I/O 多路复用机制，在单线程模型下实现高效的网络 I/O，从而支持高并发的请求处理。</p><h4 id="举例子说一下-i-o-多路复用" tabindex="-1"><a class="header-anchor" href="#举例子说一下-i-o-多路复用" aria-hidden="true">#</a> 举例子说一下 I/O 多路复用</h4><p>假设你是一个老师，让 30 个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ul><li>第一种选择：按顺序逐个检查，先检查 A，然后是 B，之后是 C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理 socket，根本不具有并发能力。</li><li>第二种选择：你创建 30 个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</li><li>第三种选择，你站在讲台上等，谁解答完谁举手。这时 C、D 举手，表示他们解答问题完毕，你下去依次检查 C、D 的答案，然后继续回到讲台上等。此时 E、A 又举手，然后去处理 E 和 A。</li></ul><p>第一种就是阻塞 IO 模型，第三种就是 I/O 复用模型。</p><p>Linux 系统有三种方式实现 IO 多路复用：select、poll 和 epoll。</p><ol><li><p><code>select</code> —— “不断喊号的大堂服务员”，每隔几秒钟，就大声喊一遍：“有没有人准备好点餐？”</p><ul><li><p>你最多只能处理 1024 桌（系统的 <code>FD_SETSIZE</code> 限制）。</p></li><li><p>人多的时候，你光是走来走去问话就要花掉大部分时间，效率低下。</p></li><li><p>遍历所有 socket</p></li><li><p>需要不断调用 <code>select</code></p></li></ul></li><li><p><code>poll</code> —— “拿着顾客名单逐个问”，换了一种方式，不再大声喊，而是<strong>拿着一个顾客名单，逐一走过去询问</strong>：“请问你准备好点餐了吗？”，你可以处理<strong>更多桌</strong>的顾客，不受 1024 的限制，但你<strong>每次还是得一个个地问</strong>。</p><ul><li>解决了 <code>select</code> 的数量限制（支持更多的顾客）。</li><li>每次询问仍然<strong>需要遍历所有的顾客</strong>，如果 99 桌顾客都没准备好，你还是得白跑一趟。</li><li>遍历所有 socket</li><li>需要不断调用 <code>poll</code></li></ul></li><li><p><code>epoll</code> —— “顾客举手示意服务员”</p><ul><li>只有<strong>需要点单</strong>的顾客才会通知你，避免了不必要的询问，提高了效率。</li><li>只处理活跃 socket</li><li>只在有事件时 <code>epoll_wait</code> 才触发</li></ul></li></ol><h3 id="redis-为什么快呢" tabindex="-1"><a class="header-anchor" href="#redis-为什么快呢" aria-hidden="true">#</a> Redis 为什么快呢？</h3><p>①、<strong>基于内存的数据存储</strong>，Redis 将数据存储在内存当中，没有磁盘的io操作</p><p>②、<strong>单线程模型</strong>，这意味着在任何时刻只有一个命令在执行。这样就避免了线程切换和锁竞争带来的消耗。</p><p>③、<strong>IO 多路复⽤</strong>，基于 Linux 的 select/epoll 机制。处理大量客户端的 Socket 请求，内核会一直监听这些Socket上的连接请求或者数据请求，一旦有请求到达，就会交给 Redis 处理，因为这是基于非阻塞的 I/O 模型，这就让 Redis 可以高效地进行网络通信，I/O 的读写流程也不再阻塞。就实现了所谓的 Redis 单个线程处理多个 IO 读写的请求。</p><p>④、<strong>高效的数据结构</strong></p><p>比如说String采用SDS简单动态字符串</p><table><thead><tr><th>操作</th><th>C 语言 <code>char*</code></th><th>Redis SDS</th></tr></thead><tbody><tr><td>计算长度</td><td>O(n)</td><td>O(1)</td></tr><tr><td>追加字符串</td><td>可能需要 <code>malloc</code></td><td>可能不会 <code>malloc</code>（因为有 <code>free</code> 预分配）</td></tr><tr><td>删除字符串</td><td>立即释放</td><td>惰性释放，减少碎片化</td></tr></tbody></table><p>hash采用哈希表，能够动态扩容，还采用链地址法</p><p>压缩列表（ZipList），当哈希表或列表数据量较小时，Redis <strong>不会使用哈希表或链表</strong>，而是使用压缩列表来节省内存。</p><p>采用跳表（Skip List），查询更快，也适合范围查询，相比于红黑树，跳表的范围查询更简单高效。</p><h3 id="redis-可以用来干什么" tabindex="-1"><a class="header-anchor" href="#redis-可以用来干什么" aria-hidden="true">#</a> Redis 可以用来干什么？</h3><ol><li>缓存，Token 、验证码、分布式锁的存储，对省市区数据的缓存</li><li>计数器，天然支持计数功能，而且计数性能非常好，可以用来记录浏览量、点赞、登录失败次数计数等等</li><li>排行榜，Zset，实时展示用户的活跃度。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、粉丝、共同好友/喜好</li><li>消息队列，提供了发布订阅功能和阻塞队列的功能</li><li>分布式锁，电商项目中，用户注册、超卖、秒杀</li></ol><h3 id="redis-常用命令" tabindex="-1"><a class="header-anchor" href="#redis-常用命令" aria-hidden="true">#</a> Redis 常用命令</h3><p>①、操作字符串的命令有：<code>SET key value</code>，<code>get</code>，<code>del</code>，<code>incr key</code>，<code>decr key</code></p><p>②、操作列表的命令有：<code>LPUSH</code>, <code> RPUSH</code>, <code>LPOP</code>, <code>RPOP</code>, <code>LRANGE key start stop</code></p><p>③、操作集合的命令有：<code>SADD</code>，<code>SREM</code>，<code>SMEMBERS</code></p><p>④、操作哈希的命令有：<code>HSET</code>，<code>HSET</code></p><h3 id="为什么-redis-不使用-b-tree-作为存储数据结构" tabindex="-1"><a class="header-anchor" href="#为什么-redis-不使用-b-tree-作为存储数据结构" aria-hidden="true">#</a> 为什么 Redis 不使用 B+ Tree 作为存储数据结构？</h3><p>Redis 主要设计为内存存储系统，B+ Tree 更适合磁盘存储系统，因为它可以减少磁盘I/O操作。Redis优先考虑的是访问速度和内存效率。</p><h3 id="redis-网络-io-模型用的是什么" tabindex="-1"><a class="header-anchor" href="#redis-网络-io-模型用的是什么" aria-hidden="true">#</a> Redis 网络 IO 模型用的是什么？</h3><p>使用非阻塞IO和IO多路复用技术。</p><blockquote><p>简而言之，非阻塞I/O让程序不必等待一个操作完成才能继续做其他事，而I/O多路复用让程序能同时监控多个操作，一旦有操作完成就立刻处理，这两种技术都是为了让程序运行得更高效</p><p>在技术上，这意味着Redis可以使用一个进程（服务员）来同时监控多个网络连接（顾客），并且只关注那些&quot;举手&quot;（即准备好进行数据交换的连接）。这让Redis能够非常高效地处理成千上万的连接，而不需要为每个连接分配单独的资源或服务员。</p></blockquote>`,78),l=[t];function n(r,o){return i(),a("div",null,l)}const c=e(d,[["render",n],["__file","3.Redis Base.html.vue"]]);export{c as default};
