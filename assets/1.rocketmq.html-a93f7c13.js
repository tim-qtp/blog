import{_ as e,W as o,X as r,a2 as i}from"./framework-48328e23.js";const a={},t=i('<h3 id="_1-为什么要使用消息队列呢" tabindex="-1"><a class="header-anchor" href="#_1-为什么要使用消息队列呢" aria-hidden="true">#</a> 1.为什么要使用消息队列呢？</h3><p>消息队列（Message Queue, MQ）是一种非常重要的中间件技术，广泛应用于分布式系统中，以提高系统的可用性、解耦能力和异步通信效率。</p><p>①、<strong>解耦</strong></p><p>实现解耦 其他的动作一定程度上和我没有关系消息丢进队列里，下游服务自己去调用</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503081101176.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>像任务审批，就用了 RocketMQ 来做解耦。</p><p>②、<strong>异步</strong>：</p><p>系统可以将那些耗时的任务放在消息队列中异步处理，从而快速响应用户的请求。比如说，用户下单后，系统可以先返回一个下单成功的消息，然后将订单信息放入消息队列中，后台系统再去处理订单信息（扣减库存，增加积分，发送消息），链路一长，响应时间就变长了，引入消息队列，除了更新订单状态，其它的都可以异步去做，这样一来就来，就能降低响应时间。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503081054928.jpeg" alt="消息队列异步" tabindex="0" loading="lazy"><figcaption>消息队列异步</figcaption></figure><p>③、<strong>削峰</strong>：</p><p>削峰填谷是一种常见的技术手段，用于应对系统高并发请求的瞬时流量高峰，通过消息队列，可以将瞬时的高峰流量转化为持续的低流量，从而保护系统不会因为瞬时的高流量而崩溃。</p><p>**缺点：</p><p>宕机后整个业务就会产生影响</p><p>引入MQ后，数据链路就会变得很复杂</p><p>还得考虑喜消息不丢失问题，顺序问题，重复消费问题</p><h3 id="_2-为什么要选择-rocketmq" tabindex="-1"><a class="header-anchor" href="#_2-为什么要选择-rocketmq" aria-hidden="true">#</a> 2.为什么要选择 RocketMQ?</h3><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503081548289.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>RocketMQ</code> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code>Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在 2016 年底贡献给 <code>Apache</code>，成为了 <code>Apache</code> 的一个顶级项目。 在阿里内部，<code>RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code>RocketMQ</code> 流转。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503081105124.jpeg" alt="四大消息队列对比" tabindex="0" loading="lazy"><figcaption>四大消息队列对比</figcaption></figure><p>平时做的系统主要面向 C 端用户，有一定的并发量，对性能也有比较高的要求，所以选择了低延迟、吞吐量比较高，可用性比较好的 RocketMQ。</p><h3 id="_3-rocketmq-有什么优缺点" tabindex="-1"><a class="header-anchor" href="#_3-rocketmq-有什么优缺点" aria-hidden="true">#</a> 3.RocketMQ 有什么优缺点？</h3><p>RocketMQ 优点：</p><ul><li>单机吞吐量：十万级</li><li>可用性：非常高，分布式架构</li><li>消息可靠性：经过参数优化配置，消息可以做到 0 丢失</li><li>功能支持：MQ 功能较为完善，还是分布式的，扩展性好</li><li>支持 10 亿级别的消息堆积，不会因为堆积导致性能下降</li><li>源码是 Java，方便结合公司自己的业务二次开发</li><li>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况</li><li><strong>RoketMQ</strong>在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择<strong>RocketMQ</strong></li></ul><p>RocketMQ 缺点：</p><ul><li>支持的客户端语言不多，目前是 Java 及 c++，其中 c++不成熟</li><li>没有在 MQ 核心中去实现<strong>JMS</strong>等接口，有些系统要迁移需要修改大量代码</li></ul><h3 id="_4-消息队列有哪些消息模型" tabindex="-1"><a class="header-anchor" href="#_4-消息队列有哪些消息模型" aria-hidden="true">#</a> 4.消息队列有哪些消息模型？</h3><p>消息队列有两种模型：<strong>队列模型</strong>和<strong>发布/订阅模型</strong>。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503081519336.png" alt="队列模型" tabindex="0" loading="lazy"><figcaption>队列模型</figcaption></figure><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503081519340.jpeg" alt="发布-订阅模型" tabindex="0" loading="lazy"><figcaption>发布-订阅模型</figcaption></figure><h3 id="_5-那-rocketmq-的消息模型呢" tabindex="-1"><a class="header-anchor" href="#_5-那-rocketmq-的消息模型呢" aria-hidden="true">#</a> 5.那 RocketMQ 的消息模型呢？</h3><p><code>RocketMQ</code> 中的消息模型就是按照 <strong>主题模型</strong> 所实现的。</p><p>其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code>Kafka</code> 中的 <strong>分区</strong> ，<code>RocketMQ</code> 中的 <strong>队列</strong> ，<code>RabbitMQ</code> 中的 <code>Exchange</code> 。我们可以理解为 <strong>主题模型/发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503081846841.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>假设我们有一个电商系统，系统中有以下功能：</p><ol><li><strong>下单</strong>：用户下单后生成订单。</li><li><strong>支付</strong>：用户支付订单。</li><li><strong>发货</strong>：商家发货后更新物流信息。</li></ol><hr><h4 id="_1-topic-主题" tabindex="-1"><a class="header-anchor" href="#_1-topic-主题" aria-hidden="true">#</a> 1. <strong>Topic（主题）</strong></h4><ul><li><strong>Topic 是消息的归类</strong>，比如我们可以定义两个 Topic： <ul><li><code>OrderTopic</code>：用于处理订单相关的消息。</li><li><code>LogisticsTopic</code>：用于处理物流相关的消息。</li></ul></li></ul><hr><h4 id="_2-message-消息" tabindex="-1"><a class="header-anchor" href="#_2-message-消息" aria-hidden="true">#</a> 2. <strong>Message（消息）</strong></h4><ul><li><strong>消息是传输的信息</strong>，比如： <ul><li>用户下单后，生成一条消息，内容是订单信息（如订单号、商品信息等），这条消息的 Topic 是 <code>OrderTopic</code>。</li><li>用户支付后，生成一条消息，内容是支付信息（如订单号、支付金额等），这条消息的 Topic 也是 <code>OrderTopic</code>。</li><li>商家发货后，生成一条消息，内容是物流信息（如订单号、快递单号等），这条消息的 Topic 是 <code>LogisticsTopic</code>。</li></ul></li></ul><hr><h4 id="_3-tag-标签" tabindex="-1"><a class="header-anchor" href="#_3-tag-标签" aria-hidden="true">#</a> 3. <strong>Tag（标签）</strong></h4><ul><li><strong>Tag 是消息的子分类</strong>，用于更细粒度地标识消息。比如： <ul><li>在 <code>OrderTopic</code> 下，我们可以定义两个 Tag： <ul><li><code>CreateOrder</code>：表示订单创建的消息。</li><li><code>PayOrder</code>：表示订单支付的消息。</li></ul></li><li>在 <code>LogisticsTopic</code> 下，我们可以定义一个 Tag： <ul><li><code>ShipOrder</code>：表示订单发货的消息。</li></ul></li></ul></li><li>这样，生产者发送消息时，可以指定 Topic 和 Tag： <ul><li>下单时发送的消息：<code>Topic=OrderTopic, Tag=CreateOrder</code>。</li><li>支付时发送的消息：<code>Topic=OrderTopic, Tag=PayOrder</code>。</li><li>发货时发送的消息：<code>Topic=LogisticsTopic, Tag=ShipOrder</code>。</li></ul></li></ul><hr><h4 id="_4-group-消费组" tabindex="-1"><a class="header-anchor" href="#_4-group-消费组" aria-hidden="true">#</a> 4. <strong>Group（消费组）</strong></h4><ul><li><strong>消费组是一组消费者的集合</strong>，它们共同消费一个 Topic 下的消息。比如： <ul><li>我们可以定义一个消费组 <code>OrderGroup</code>，用于处理订单相关的消息。</li><li>另一个消费组 <code>LogisticsGroup</code>，用于处理物流相关的消息。</li></ul></li><li><strong>消费组的特点</strong>： <ul><li>同一个消费组内的消费者是竞争关系，一条消息只会被组内的一个消费者消费。</li><li>不同消费组之间是独立的，一条消息可以被多个消费组分别消费。</li></ul></li></ul><hr><h4 id="_5-message-queue-消息队列" tabindex="-1"><a class="header-anchor" href="#_5-message-queue-消息队列" aria-hidden="true">#</a> 5. <strong>Message Queue（消息队列）</strong></h4><ul><li><strong>一个 Topic 下可以设置多个消息队列</strong>，比如： <ul><li><code>OrderTopic</code> 下有 4 个消息队列（Queue1、Queue2、Queue3、Queue4）。</li><li><code>LogisticsTopic</code> 下有 2 个消息队列（Queue1、Queue2）。</li></ul></li><li><strong>消费者的消费方式</strong>： <ul><li>如果消费组 <code>OrderGroup</code> 有 2 个消费者（Consumer1 和 Consumer2），那么它们会分别从 <code>OrderTopic</code> 的 4 个队列中消费消息： <ul><li>Consumer1 消费 Queue1 和 Queue2。</li><li>Consumer2 消费 Queue3 和 Queue4。</li></ul></li></ul></li></ul><hr><h4 id="_6-offset-消费位置" tabindex="-1"><a class="header-anchor" href="#_6-offset-消费位置" aria-hidden="true">#</a> 6. <strong>Offset（消费位置）</strong></h4><ul><li><strong>Offset 是消息的消费进度</strong>，比如： <ul><li>在 <code>OrderTopic</code> 的 Queue1 中，有 100 条消息。</li><li>消费组 <code>OrderGroup</code> 已经消费了前 50 条消息，那么它的 Offset 就是 50。</li><li>消费组 <code>LogisticsGroup</code> 还没有消费过 Queue1 的消息，那么它的 Offset 就是 0。</li></ul></li><li><strong>Offset 的作用</strong>： <ul><li>确保每条消息只会被消费组消费一次。</li><li>如果消费者宕机，重启后可以从上次的 Offset 继续消费。</li></ul></li></ul><h3 id="_6-消息的消费模式" tabindex="-1"><a class="header-anchor" href="#_6-消息的消费模式" aria-hidden="true">#</a> 6.消息的消费模式？</h3><p>消息消费模式有两种：<strong>Clustering</strong>（集群消费）和<strong>Broadcasting</strong>（广播消费）。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503081859336.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>默认情况下就是集群消费，这种模式下<code>一个消费者组共同消费一个主题的多个队列，一个队列只会被一个消费者消费</code>，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p><p>而广播消费消息会发给消费者组中的每一个消费者进行消费。</p><h3 id="_7-roctetmq-基本架构" tabindex="-1"><a class="header-anchor" href="#_7-roctetmq-基本架构" aria-hidden="true">#</a> 7.RoctetMQ 基本架构？</h3><p>一共有四个部分组成：NameServer，Broker，Producer 生产者，Consumer 消费者，它们对应了：发现、发、存、收，为了保证高可用，一般每一部分都是集群部署的。</p><p>类比一下我们生活的邮政系统——</p><p>邮政系统要正常运行，离不开下面这四个角色， 一是发信者，二 是收信者， 三是负责暂存传输的邮局， 四是负责协调各个地方邮局的管理机构。对应到 RocketMQ 中，这四个角色就是 Producer、 Consumer、 Broker 、NameServer。</p><figure><img src="https://qtp-1324720525.cos.ap-shanghai.myqcloud.com/blog/202503081910792.jpeg" alt="RocketMQ类比邮政体系" tabindex="0" loading="lazy"><figcaption>RocketMQ类比邮政体系</figcaption></figure><h5 id="nameserver" tabindex="-1"><a class="header-anchor" href="#nameserver" aria-hidden="true">#</a> NameServer</h5><p>NameServer 是一个无状态的服务器，角色类似于 Kafka 使用的 Zookeeper，但比 Zookeeper 更轻量。</p><p>特点：</p><ul><li>每个 NameServer 结点之间是相互独立，彼此没有任何信息交互。</li><li>Nameserver 被设计成几乎是无状态的，通过部署多个结点来标识自己是一个伪集群，Producer 在发送消息前从 NameServer 中获取 Topic 的路由信息也就是发往哪个 Broker，Consumer 也会定时从 NameServer 获取 Topic 的路由信息，Broker 在启动时会向 NameServer 注册，并定时进行心跳连接，且定时同步维护的 Topic 到 NameServer。</li></ul><p>功能主要有两个：</p><ul><li>1、和 Broker 结点保持长连接。</li><li>2、维护 Topic 的路由信息。</li></ul><h5 id="broker" tabindex="-1"><a class="header-anchor" href="#broker" aria-hidden="true">#</a> Broker</h5><p>消息存储和中转角色，负责存储和转发消息。</p><ul><li><p>Broker 内部维护着一个个 Consumer Queue，用来存储消息的索引，真正存储消息的地方是 CommitLog（日志文件）。</p></li><li><p>单个 Broker 与所有的 Nameserver 保持着长连接和心跳，并会定时将 Topic 信息同步到 NameServer，和 NameServer 的通信底层是通过 Netty 实现的</p></li></ul><h5 id="producer" tabindex="-1"><a class="header-anchor" href="#producer" aria-hidden="true">#</a> Producer</h5><p>消息生产者，业务端负责发送消息，由用户自行实现和分布式部署。</p><ul><li><strong>Producer</strong>由用户进行分布式部署，消息由<strong>Producer</strong>通过多种负载均衡模式发送到<strong>Broker</strong>集群，发送低延时，支持快速失败。</li></ul><p><strong>RocketMQ</strong> 提供了三种方式发送消息：同步、异步和单向</p><ul><li><strong>同步发送</strong>：同步发送指消息发送方发出数据后会在收到<mark>接收方发回响应之后</mark>才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</li><li><strong>异步发送</strong>：异步发送指发送方发出完数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如<mark>用户视频上传</mark>后通知启动<mark>转码</mark>服务。转码完成后，转码服务会通过回调函数通知你。</li><li><strong>单向发送</strong>：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如<mark>日志收集</mark>。</li></ul><h5 id="consumer" tabindex="-1"><a class="header-anchor" href="#consumer" aria-hidden="true">#</a> Consumer</h5><p>消息消费者，负责消费消息，一般是后台系统负责异步消费。</p><ul><li><strong>Consumer</strong>也由用户部署，支持 PUSH 和 PULL 两种消费模式，支持<strong>集群消费</strong>和<strong>广播消费</strong>，提供<strong>实时的消息订阅机制</strong>。</li><li><strong>Pull</strong>：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。</li><li><strong>Push</strong>：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push 称为被动消费类型，但其实从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push 首先要注册消费监听器，当监听器处触发后才开始消费消息。</li></ul>',80),l=[t];function c(s,n){return o(),r("div",null,l)}const g=e(a,[["render",c],["__file","1.rocketmq.html.vue"]]);export{g as default};
