import{_ as o,W as t,X as n,a2 as e}from"./framework-6a3aa88c.js";const s={},l=e("<p><strong>场景描述：</strong></p><p>用户在电商平台下单购买商品，订单系统需要记录订单信息，同时积分系统需要为用户增加相应的积分。为确保这两个操作的一致性，我们引入 RocketMQ 的事务消息机制。</p><p><strong>实现步骤：</strong></p><ol><li><p><strong>发送半事务消息：</strong></p><p>订单系统在接收到用户下单请求后，首先向 RocketMQ 发送一条半事务消息，表示即将执行订单创建和积分增加的操作。此时，这条消息对消费者（积分系统）不可见。</p></li><li><p><strong>执行本地事务：</strong></p><p>在发送半事务消息后，订单系统开始执行本地事务，包括：</p><ul><li>在订单数据库中创建新的订单记录。</li><li>在事务日志表中记录此次操作，用于后续的事务回查。</li></ul></li><li><p><strong>提交事务状态：</strong></p><p>本地事务执行完毕后，订单系统根据执行结果向 RocketMQ 提交二次确认：</p><ul><li><strong>如果本地事务执行成功</strong>，则提交 <code>Commit</code>，RocketMQ 会将之前的半事务消息标记为可投递，积分系统即可消费该消息，增加用户积分。</li><li><strong>如果本地事务执行失败</strong>，则提交 <code>Rollback</code>，RocketMQ 会删除该半事务消息，确保积分系统不会消费到此消息。</li></ul></li><li><p><strong>事务回查：</strong></p><p>在某些情况下，例如网络异常或订单系统崩溃，RocketMQ 未收到二次确认。此时，RocketMQ 会定期对未确认的半事务消息进行回查，通过调用订单系统预先实现的 <code>checkLocalTransaction</code> 方法，查询本地事务的实际执行结果，并根据查询结果决定是提交还是回滚消息。</p></li></ol><p><strong>关键点：</strong></p><ul><li><strong>半事务消息：</strong> 指暂时对消费者不可见的消息，只有在收到生产者的 <code>Commit</code> 确认后，才会对消费者可见。</li><li><strong>事务日志表：</strong> 用于记录本地事务的执行情况，便于在事务回查时确定事务的最终状态。</li><li><strong>事务回查：</strong> RocketMQ 的补偿机制，确保在异常情况下也能保证消息和本地事务的一致性。</li></ul>",6),c=[l];function i(r,p){return t(),n("div",null,c)}const a=o(s,[["render",i],["__file","11.Implementation of transaction messages in RocketMQ.html.vue"]]);export{a as default};
